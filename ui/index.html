<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Judex - Video Evaluation</title>
    <!-- Marked.js for markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --black: #000000;
            --white: #ffffff;
            --gray-dark: #1a1a1a;
            --gray-medium: #333333;
            --gray-light: #666666;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--black);
            color: var(--white);
            line-height: 1.6;
            display: flex;
            min-height: 100vh;
        }

        /* Sidebar Navigation */
        .sidebar {
            width: 60px;
            background: var(--black);
            border-right: 1px solid var(--gray-medium);
            position: fixed;
            left: 0;
            top: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            z-index: 1000;
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }

        .sidebar:hover {
            width: 220px;
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.5);
        }

        .sidebar-brand {
            padding: 22px 0;
            font-size: 1.5em;
            font-weight: 700;
            text-align: center;
            border-bottom: 1px solid var(--gray-medium);
            letter-spacing: 2px;
            white-space: nowrap;
            position: relative;
            min-height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sidebar-brand-icon {
            font-size: 1.2em;
            display: block;
        }

        .sidebar:hover .sidebar-brand-icon {
            display: none;
        }

        .sidebar-brand-text {
            display: none;
        }

        .sidebar:hover .sidebar-brand-text {
            display: block;
        }

        .sidebar-nav {
            flex: 1;
            padding: 20px 0;
        }

        .sidebar-link {
            display: flex;
            align-items: center;
            gap: 0;
            padding: 16px 0;
            color: var(--gray-light);
            text-decoration: none;
            font-weight: 400;
            font-size: 0.8em;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
            white-space: nowrap;
            position: relative;
        }

        .sidebar-link:hover {
            color: var(--white);
            background: var(--gray-dark);
            border-left-color: var(--gray-light);
        }

        .sidebar-link.active {
            color: var(--white);
            background: var(--gray-dark);
            border-left-color: var(--white);
        }

        .sidebar-icon {
            font-size: 1.2em;
            width: 60px;
            min-width: 60px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            font-style: normal;
        }

        .sidebar-icon::before {
            font-family: monospace;
            font-weight: 700;
        }

        .sidebar-text {
            opacity: 0;
            transition: opacity 0.2s ease;
            padding-right: 20px;
        }

        .sidebar:hover .sidebar-text {
            opacity: 1;
        }

        /* Tooltip for collapsed state */
        .sidebar-link::after {
            content: attr(data-label);
            position: absolute;
            left: 65px;
            background: var(--white);
            color: var(--black);
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 0.75em;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 1001;
        }

        .sidebar:not(:hover) .sidebar-link:hover::after {
            opacity: 1;
        }

        .sidebar:hover .sidebar-link::after {
            display: none;
        }

        /* Main Layout */
        .main-content {
            flex: 1;
            margin-left: 60px;
            padding: 40px 60px;
            width: calc(100% - 60px);
            transition: margin-left 0.3s cubic-bezier(0.4, 0, 0.2, 1), width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Tab Content */
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Remove page header spacing */
        .page-header {
            display: none;
        }

        /* Header Section */
        .page-header {
            margin-bottom: 40px;
        }

        .page-title {
            font-size: 2.5em;
            font-weight: 700;
            margin-bottom: 10px;
            letter-spacing: -1px;
        }

        .page-subtitle {
            color: var(--text-gray);
            font-size: 1.1em;
        }

        /* Panel System - Minimal Borders */
        .panel {
            background: transparent;
            border: none;
            border-bottom: 1px solid var(--gray-medium);
            padding: 40px 0;
            margin-bottom: 0;
            transition: border-color 0.2s ease;
        }

        .panel:last-child {
            border-bottom: none;
        }

        .panel:hover {
            border-color: var(--gray-light);
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 0;
            border-bottom: none;
        }

        .panel-title {
            font-size: 0.75em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 3px;
            font-size: 0.7em;
            color: var(--gray-light);
        }

        /* Upload Zone */
        .upload-zone {
            border: 1px dashed var(--gray-medium);
            padding: 80px 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            background: transparent;
        }

        .upload-zone:hover {
            border-color: var(--white);
            border-style: solid;
        }

        .upload-zone.dragover {
            border-color: var(--white);
            background: var(--gray-dark);
            border-style: solid;
        }

        .upload-icon {
            font-size: 4em;
            margin-bottom: 25px;
            opacity: 0.3;
            transition: opacity 0.2s;
        }

        .upload-icon::before {
            content: '↑';
            font-weight: 300;
            font-style: normal;
        }

        .upload-zone:hover .upload-icon {
            opacity: 0.6;
        }

        .upload-text {
            font-size: 0.85em;
            margin-bottom: 12px;
            color: var(--white);
            font-weight: 400;
            letter-spacing: 1.5px;
            text-transform: uppercase;
        }

        .upload-subtext {
            color: var(--gray-light);
            font-size: 0.7em;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        /* Step Indicator */
        .step-indicator {
            text-align: left;
            margin-bottom: 40px;
            padding: 0 0 20px 0;
            border-bottom: 1px solid var(--gray-medium);
        }

        .step-number {
            font-size: 0.6em;
            color: var(--gray-light);
            letter-spacing: 2px;
            margin-bottom: 6px;
            font-weight: 400;
            text-transform: uppercase;
        }

        .step-title {
            font-size: 0.7em;
            color: var(--white);
            font-weight: 400;
            letter-spacing: 1.5px;
            text-transform: uppercase;
        }

        /* Upload State Animations */
        .upload-zone.uploading {
            pointer-events: none;
            opacity: 0.6;
        }

        .upload-zone.uploading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border: 3px solid var(--gray-medium);
            border-top-color: var(--white);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* Video Player */
        .video-player {
            width: 100%;
            max-width: 900px;
            margin: 0 auto 30px;
        }

        .video-player video {
            width: 100%;
            background: var(--black);
            border: 1px solid var(--gray-medium);
        }

        input[type="file"] {
            display: none;
        }

        /* File Info */
        .file-info {
            display: none;
            margin-top: 30px;
            padding: 30px;
            background: var(--black);
            border: 1px solid var(--gray-medium);
        }

        .file-info.show {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 30px;
        }

        .file-details {
            display: flex;
            align-items: center;
            gap: 20px;
            flex: 1;
        }

        .file-icon {
            font-size: 3em;
        }

        .file-name {
            font-weight: 500;
            color: var(--white);
            font-size: 1.1em;
            margin-bottom: 5px;
        }

        .file-size {
            color: var(--gray-light);
            font-size: 0.9em;
        }

        /* Button System */
        .btn {
            padding: 14px 32px;
            border: 1px solid var(--white);
            background: transparent;
            font-size: 0.8em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            color: var(--white);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .btn:hover {
            background: var(--white);
            color: var(--black);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 255, 255, 0.15);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            border-color: var(--gray-medium);
            color: var(--gray-medium);
            cursor: not-allowed;
        }

        .btn:disabled:hover {
            background: transparent;
            color: var(--gray-medium);
        }

        /* Large primary button */
        #analyzeBtn {
            padding: 20px 60px;
            font-size: 1em;
            min-width: 280px;
        }

        /* Loading State */
        .loading-state {
            display: none;
            padding: 40px 20px;
        }

        .loading-state.show {
            display: block;
        }
        
        /* Results section appears below pipeline when complete */
        .results-section {
            display: none;
        }
        
        .results-section.show {
            display: block;
        }

        .pipeline-flow {
            margin: 40px 0;
        }

        .pipeline-stages {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 30px;
            padding: 30px;
            background: var(--gray-dark);
            border: 1px solid var(--gray-medium);
            overflow-x: auto;
        }

        .pipeline-stage {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            flex: 0 0 auto;
            margin: 0 15px;
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        
        .pipeline-stage:hover {
            transform: translateY(-3px);
        }
        
        .pipeline-stage.clickable {
            opacity: 1;
        }
        
        .pipeline-stage.clickable:hover .stage-icon-wrapper {
            border-color: var(--white);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
        }

        .stage-icon-wrapper {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid var(--gray-medium);
            background: var(--black);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            margin-bottom: 10px;
            position: relative;
        }

        .pipeline-stage.active .stage-icon-wrapper {
            border-color: var(--white);
            background: var(--white);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            animation: pulse 2s ease-in-out infinite;
        }

        .pipeline-stage.completed .stage-icon-wrapper {
            border-color: var(--white);
            background: var(--white);
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 255, 255, 0.3); }
            50% { box-shadow: 0 0 30px rgba(255, 255, 255, 0.6); }
        }

        .stage-number {
            font-size: 0.9em;
            color: var(--gray-light);
            font-weight: 500;
        }

        .pipeline-stage.active .stage-number {
            color: var(--black);
        }

        .pipeline-stage.completed .stage-number {
            display: none;
        }

        .stage-status {
            font-size: 1.2em;
            display: none;
        }

        .pipeline-stage.active .stage-status {
            display: block;
            animation: spin 1s linear infinite;
        }

        .pipeline-stage.completed .stage-status {
            display: block;
            color: var(--black);
        }

        .stage-name {
            font-size: 0.7em;
            color: var(--white);
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: center;
            white-space: nowrap;
        }

        .stage-time {
            margin-top: 5px;
            font-size: 0.65em;
            color: var(--gray-light);
            font-family: 'Courier New', monospace;
        }

        .pipeline-message {
            text-align: center;
            margin: 30px 0;
            padding: 25px;
            background: var(--black);
            border: 1px solid var(--gray-medium);
        }

        .current-stage {
            font-size: 0.7em;
            color: var(--gray-light);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
        }

        .stage-description {
            font-size: 1em;
            color: var(--white);
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 2px solid var(--gray-medium);
            border-top: 2px solid var(--white);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 30px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 1.2em;
            margin-bottom: 10px;
        }

        .loading-subtext {
            color: var(--gray-light);
            font-size: 0.9em;
        }

        .progress-bar {
            width: 100%;
            height: 2px;
            background: var(--gray-medium);
            margin: 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--white);
            width: 0%;
            transition: width 0.5s ease;
        }

        /* Results Section */
        .results-section {
            display: none;
        }

        .results-section.show {
            display: block;
        }

        /* Video Player */
        .video-player {
            background: var(--black);
            padding: 0;
            position: relative;
        }

        .video-player video {
            width: 100%;
            height: auto;
            display: block;
            background: var(--black);
        }

        .video-timeline-wrapper {
            position: relative;
            margin-top: -5px;
            height: 30px;
            background: var(--gray-dark);
            border: 1px solid var(--gray-medium);
            border-top: none;
        }

        .video-timeline-markers {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 100%;
            pointer-events: none;
        }

        .timeline-marker {
            position: absolute;
            top: 0;
            bottom: 0;
            background: rgba(255, 0, 0, 0.6);
            border-left: 2px solid #ff0000;
            border-right: 2px solid #ff0000;
            transition: opacity 0.2s;
            cursor: pointer;
        }

        .timeline-marker:hover {
            opacity: 0.9;
            background: rgba(255, 0, 0, 0.8);
        }

        .timeline-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--black);
            color: var(--white);
            padding: 8px 12px;
            border: 1px solid var(--white);
            font-size: 0.75em;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            margin-bottom: 5px;
            z-index: 10;
        }

        .timeline-marker:hover .timeline-tooltip {
            opacity: 1;
        }

        .timeline-legend {
            padding: 10px 20px;
            font-size: 0.75em;
            color: var(--gray-light);
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .timeline-legend span {
            color: #ff0000;
            font-weight: 500;
        }

        /* Verdict Display */
        .verdict-display {
            text-align: center;
            padding: 60px 40px;
            margin-bottom: 30px;
            border: 1px solid var(--gray-medium);
        }

        .verdict-label {
            font-size: 0.75em;
            color: var(--gray-light);
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .verdict-badge {
            display: inline-block;
            padding: 20px 50px;
            font-size: 2.5em;
            font-weight: 700;
            letter-spacing: 3px;
            border: 2px solid var(--white);
            background: var(--black);
            color: var(--white);
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1px;
            background: var(--gray-medium);
            border: 1px solid var(--gray-medium);
            margin-bottom: 30px;
        }

        .stat-card {
            background: var(--black);
            padding: 25px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.75em;
            color: var(--gray-light);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .stat-value {
            font-size: 2em;
            font-weight: 300;
            color: var(--white);
        }

        /* Criteria Display */
        .criteria-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1px;
            background: var(--gray-medium);
            border: 1px solid var(--gray-medium);
            margin: 25px 0;
        }

        .criterion-card {
            background: var(--black);
            padding: 30px 25px;
            transition: background 0.2s ease;
        }

        .criterion-card:hover {
            background: var(--gray-dark);
        }

        .criterion-card.status-violation {
            border-left: 3px solid var(--white);
        }

        .criterion-card.status-caution {
            border-left: 3px solid var(--gray-light);
        }

        .criterion-card.status-ok {
            border-left: none;
        }

        .criterion-name {
            font-weight: 400;
            font-size: 0.75em;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 15px;
            color: var(--gray-light);
        }

        .criterion-score {
            font-size: 3em;
            font-weight: 300;
            margin: 10px 0;
        }

        .criterion-status {
            font-size: 0.7em;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 10px;
            color: var(--gray-light);
        }

        /* New Analytics Layout Styles */
        .criteria-analysis-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 15px;
        }

        .criterion-analysis-card {
            background: transparent;
            border: none;
            border-top: 2px solid var(--gray-medium);
            padding: 25px 15px;
            text-align: center;
            transition: all 0.2s ease;
            position: relative;
        }

        .criterion-analysis-card.score-safe {
            border-top-color: #00aa00;
        }

        .criterion-analysis-card.score-caution {
            border-top-color: #ff9900;
        }

        .criterion-analysis-card.score-unsafe {
            border-top-color: #ff0000;
        }

        .criterion-analysis-card:hover {
            border-top-width: 3px;
            padding-top: 24px;
        }

        .criterion-analysis-name {
            font-size: 0.7em;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--gray-light);
            margin-bottom: 15px;
        }

        .criterion-analysis-score {
            font-size: 2.5em;
            font-weight: 300;
            margin: 10px 0;
            line-height: 1;
        }

        .criterion-analysis-label {
            font-size: 0.65em;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 10px;
            color: var(--gray-light);
        }

        .model-contribution-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .model-card {
            background: transparent;
            border: none;
            border-left: 2px solid var(--gray-medium);
            padding: 20px 20px 20px 25px;
            transition: all 0.2s ease;
        }

        .model-card:hover {
            border-left-color: var(--white);
            border-left-width: 3px;
            padding-left: 24px;
        }

        .model-card-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--gray-medium);
        }

        .model-icon {
            font-size: 1.5em;
        }

        .model-icon::before {
            content: '◆';
            font-weight: 300;
        }

        .model-name {
            font-size: 0.9em;
            font-weight: 500;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .model-type {
            font-size: 0.65em;
            color: var(--gray-light);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .model-detections {
            margin-top: 15px;
        }

        .detection-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid var(--gray-darker);
            font-size: 0.85em;
        }

        .detection-row:last-child {
            border-bottom: none;
        }

        .detection-label {
            color: var(--gray-light);
        }

        .detection-value {
            font-weight: 500;
        }

        .detection-value.high {
            color: #ff0000;
        }

        .detection-value.medium {
            color: #ff9900;
        }

        .detection-value.low {
            color: var(--white);
        }

        .violations-timeline {
            padding: 30px;
        }

        .violation-item {
            display: flex;
            gap: 20px;
            padding: 20px;
            background: var(--gray-dark);
            border-left: 3px solid var(--white);
            margin-bottom: 15px;
            transition: all 0.2s ease;
        }

        .violation-item:hover {
            background: var(--gray-medium);
            transform: translateX(5px);
        }

        .violation-time {
            min-width: 100px;
            font-size: 1.2em;
            font-weight: 300;
            color: var(--gray-light);
        }

        .violation-details {
            flex: 1;
        }

        .violation-criterion {
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 8px;
        }

        .violation-severity {
            display: inline-block;
            padding: 4px 12px;
            background: var(--gray-darker);
            font-size: 0.7em;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 8px;
        }

        .violation-severity.high {
            background: rgba(255, 0, 0, 0.2);
            color: #ff0000;
        }

        .violation-severity.medium {
            background: rgba(255, 153, 0, 0.2);
            color: #ff9900;
        }

        .criterion-bar {
            width: 100%;
            height: 1px;
            background: var(--gray-medium);
            margin-top: 20px;
        }

        .criterion-bar-fill {
            height: 100%;
            background: var(--white);
            transition: width 0.5s ease;
        }

        /* Violations Section */
        .violations-list {
            margin-top: 25px;
        }

        .violation-item {
            background: var(--black);
            border: 1px solid var(--gray-medium);
            border-left: 3px solid var(--white);
            padding: 25px;
            margin-bottom: 20px;
        }

        .violation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .violation-title {
            font-size: 1em;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .violation-severity {
            padding: 4px 12px;
            border: 1px solid var(--gray-medium);
            font-size: 0.75em;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .violation-details {
            color: var(--gray-light);
            margin: 10px 0;
            font-size: 0.9em;
        }

        .timestamps {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
        }

        .timestamp-tag {
            background: var(--gray-dark);
            border: 1px solid var(--gray-medium);
            padding: 6px 12px;
            font-size: 0.85em;
            font-family: 'Courier New', monospace;
            color: var(--white);
        }

        /* Report Section - AI Summary */
        .report-content {
            background: var(--black);
            border: 1px solid var(--gray-medium);
            padding: 40px;
            margin-top: 0;
            line-height: 1.9;
            font-size: 0.95em;
        }

        .report-content h3 {
            margin-top: 35px;
            margin-bottom: 20px;
            color: var(--white);
            font-weight: 500;
            font-size: 1em;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-bottom: 1px solid var(--gray-medium);
            padding-bottom: 10px;
        }

        .report-content h3:first-child {
            margin-top: 0;
        }
        
        .report-content h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: var(--white);
            font-weight: 500;
            font-size: 1.1em;
            letter-spacing: 1px;
        }

        .report-content p {
            margin-bottom: 20px;
            color: var(--gray-light);
            font-size: 1em;
            line-height: 1.8;
        }

        .report-content ul {
            margin-left: 25px;
            margin-bottom: 20px;
        }

        .report-content li {
            margin-bottom: 12px;
            color: var(--gray-light);
            line-height: 1.7;
        }

        .report-content strong {
            color: var(--white);
            font-weight: 500;
        }

        .report-content code {
            background: var(--gray-dark);
            padding: 3px 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            border: 1px solid var(--gray-medium);
            color: var(--white);
        }
        
        .report-content blockquote {
            border-left: 3px solid var(--white);
            padding-left: 20px;
            margin: 20px 0;
            color: var(--gray-light);
            font-style: italic;
        }

        /* Stage Details Modal */
        .stage-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10000;
            overflow-y: auto;
            backdrop-filter: blur(5px);
        }
        
        .stage-modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
        }
        
        .stage-modal-content {
            background: var(--black);
            border: 2px solid var(--white);
            max-width: 900px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 0 50px rgba(255, 255, 255, 0.2);
        }
        
        .stage-modal-header {
            padding: 25px 30px;
            border-bottom: 2px solid var(--white);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--gray-dark);
        }
        
        .stage-modal-title {
            font-size: 1.2em;
            letter-spacing: 2px;
            font-weight: 500;
        }
        
        .stage-modal-close {
            background: transparent;
            border: 1px solid var(--white);
            color: var(--white);
            padding: 8px 16px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s ease;
        }
        
        .stage-modal-close:hover {
            background: var(--white);
            color: var(--black);
        }
        
        .stage-modal-body {
            padding: 30px;
            max-height: calc(90vh - 100px);
            overflow-y: auto;
        }
        
        .stage-info {
            margin-bottom: 25px;
            padding-bottom: 25px;
            border-bottom: 1px solid var(--gray-medium);
        }
        
        .stage-info:last-child {
            border-bottom: none;
        }
        
        .stage-info-label {
            font-size: 0.75em;
            color: var(--gray-light);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
        }
        
        .stage-info-value {
            color: var(--white);
            font-size: 1em;
            line-height: 1.6;
        }
        
        .stage-data-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }
        
        .stage-data-item {
            background: var(--gray-dark);
            border: 1px solid var(--gray-medium);
            padding: 15px;
        }
        
        .stage-data-item-label {
            font-size: 0.7em;
            color: var(--gray-light);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }
        
        .stage-data-item-value {
            font-size: 1.1em;
            color: var(--white);
            font-weight: 500;
        }
        
        /* Detection Details */
        .detection-item {
            background: var(--gray-dark);
            border: 1px solid var(--gray-medium);
            padding: 20px;
            margin-bottom: 15px;
        }

        .detection-header {
            font-size: 0.75em;
            color: var(--gray-light);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
        }

        .detection-value {
            font-size: 1.1em;
            color: var(--white);
            margin-bottom: 5px;
        }

        .detection-subtext {
            font-size: 0.85em;
            color: var(--gray-light);
        }

        /* Error Display */
        .error-display {
            display: none;
            background: var(--black);
            border: 1px solid var(--white);
            padding: 30px;
            margin-bottom: 30px;
        }

        .error-display.show {
            display: block;
        }

        .error-title {
            color: var(--white);
            font-weight: 500;
            font-size: 1em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .error-message {
            color: var(--gray-light);
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--black);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--gray-medium);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--gray-light);
        }

        /* Batch Processing Table */
        .batch-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        #addVideosBtn:hover {
            background: var(--white) !important;
            color: var(--black) !important;
            transform: scale(1.05);
        }

        .videos-table {
            width: 100%;
            border-collapse: collapse;
            margin: 30px 0;
        }
        
        /* Split Pane Layout */
        #splitPaneContainer {
            display: flex;
            height: calc(100vh - 180px);
            gap: 0;
            border: 1px solid var(--gray-medium);
            border-radius: 8px;
            overflow: hidden;
            background: var(--gray-dark);
        }
        
        /* File Tree Pane (Left) */
        .file-tree-pane {
            width: 280px;
            min-width: 250px;
            max-width: 350px;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--gray-medium);
            background: var(--black);
        }
        
        .file-tree-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            border-bottom: 1px solid var(--gray-medium);
            background: var(--gray-dark);
        }
        
        .file-tree-title {
            display: flex;
            align-items: center;
            font-size: 0.75em;
            font-weight: 600;
            letter-spacing: 1.5px;
            color: var(--gray-light);
        }
        
        .file-tree-count {
            font-size: 0.7em;
            color: var(--gray-light);
            background: var(--black);
            padding: 4px 10px;
            border-radius: 12px;
        }
        
        .file-tree-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px 0;
        }
        
        /* File Tree Item */
        .file-tree-item {
            display: flex;
            align-items: center;
            padding: 12px 20px;
            cursor: pointer;
            transition: all 0.2s;
            border-left: 3px solid transparent;
            position: relative;
        }
        
        .file-tree-item:hover {
            background: var(--gray-dark);
            border-left-color: var(--primary);
        }
        
        .file-tree-item:hover .file-tree-actions {
            opacity: 1 !important;
        }
        
        .file-tree-item.active {
            background: var(--gray-medium);
            border-left-color: var(--primary);
        }
        
        .file-tree-item.active .file-tree-actions {
            opacity: 1 !important;
        }
        
        .file-tree-item.active::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: var(--primary);
        }
        
        .file-tree-icon {
            width: 32px;
            height: 32px;
            margin-right: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            background: var(--gray-dark);
            flex-shrink: 0;
        }
        
        .file-tree-item.active .file-tree-icon {
            background: var(--primary);
            color: var(--black);
        }
        
        .file-tree-details {
            flex: 1;
            min-width: 0;
        }
        
        .file-tree-name {
            font-size: 0.85em;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 4px;
        }
        
        .file-tree-meta {
            font-size: 0.7em;
            color: var(--gray-light);
            display: flex;
            gap: 10px;
        }
        
        .file-tree-status {
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }
        
        .file-tree-status-indicator {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }
        
        .file-tree-status-indicator.pending {
            background: var(--gray-light);
        }
        
        .file-tree-status-indicator.processing {
            background: #00aaff;
            animation: pulse 2s ease-in-out infinite;
        }
        
        .file-tree-status-indicator.completed {
            background: #00aa00;
        }
        
        .file-tree-status-indicator.failed {
            background: #ff0000;
        }
        
        /* Pipeline Detail Pane (Right) */
        .pipeline-detail-pane {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--gray-dark);
            overflow: hidden;
        }
        
        .pipeline-empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--gray-light);
        }
        
        .pipeline-detail-content {
            height: 100%;
            overflow: hidden;
        }
        
        /* Pipeline Header in Detail View */
        .pipeline-detail-header {
            position: sticky;
            top: 0;
            z-index: 10;
            background: var(--black);
            border-bottom: 1px solid var(--gray-medium);
            padding: 20px 30px;
        }
        
        .pipeline-detail-title {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
        }
        
        .pipeline-detail-filename {
            font-size: 1.1em;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .pipeline-detail-actions {
            display: flex;
            gap: 10px;
        }
        
        .pipeline-detail-meta {
            display: flex;
            gap: 20px;
            font-size: 0.8em;
            color: var(--gray-light);
        }
        
        .pipeline-detail-body {
            padding: 30px;
        }

        .videos-table thead {
            border-bottom: 1px solid var(--gray-medium);
        }

        .videos-table th {
            text-align: left;
            padding: 15px 10px;
            font-size: 0.7em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--gray-light);
        }

        .videos-table td {
            padding: 20px 10px;
            border-bottom: 1px solid var(--gray-medium);
            font-size: 0.85em;
        }

        .videos-table tbody tr {
            transition: background 0.2s;
        }

        .videos-table tbody tr:hover {
            background: var(--gray-dark);
        }
        
        .videos-table tbody tr td:first-child:hover span {
            color: var(--white);
            border-bottom-color: var(--white);
        }
        
        /* Video Preview Modal */
        #videoPreviewModal button:hover {
            background: var(--white) !important;
            color: var(--black) !important;
            transform: scale(1.05);
        }
        
        /* Data Source Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .modal-content {
            background: var(--gray-dark);
            border: 1px solid var(--gray-medium);
            border-radius: 4px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 25px 30px;
            border-bottom: 1px solid var(--gray-medium);
        }
        
        .close-btn {
            background: transparent;
            border: none;
            color: var(--white);
            font-size: 2em;
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }
        
        .close-btn:hover {
            background: var(--gray-medium);
            border-radius: 50%;
        }
        
        .data-source-options {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
        }
        
        .data-source-option {
            display: flex;
            align-items: center;
            gap: 20px;
            padding: 20px;
            border: 1px solid var(--gray-medium);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .data-source-option:hover {
            background: var(--gray-medium);
            border-color: var(--white);
            transform: translateX(5px);
        }
        
        .source-icon {
            font-size: 2.5em;
            width: 60px;
            text-align: center;
        }
        
        .source-info {
            flex: 1;
        }
        
        .source-title {
            font-size: 0.9em;
            font-weight: 600;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }
        
        .source-description {
            font-size: 0.8em;
            color: var(--gray-light);
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-range {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: var(--gray-medium);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }
        
        .form-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--blue);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .form-range::-webkit-slider-thumb:hover {
            background: var(--white);
            transform: scale(1.1);
        }
        
        .form-range::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--blue);
            cursor: pointer;
            border: none;
            transition: all 0.2s;
        }
        
        .form-range::-moz-range-thumb:hover {
            background: var(--white);
            transform: scale(1.1);
        }
        
        .form-group label {
            display: block;
            font-size: 0.8em;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            margin-bottom: 8px;
            color: var(--gray-light);
        }
        
        .form-input {
            width: 100%;
            padding: 12px 15px;
            background: var(--black);
            border: 1px solid var(--gray-medium);
            color: var(--white);
            font-size: 0.9em;
            font-family: inherit;
            border-radius: 4px;
            transition: border-color 0.3s;
        }
        
        .form-input:focus {
            outline: none;
            border-color: var(--white);
        }
        
        .form-input::placeholder {
            color: var(--gray-light);
        }

        .video-status {
            display: inline-block;
            padding: 4px 10px;
            font-size: 0.7em;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-radius: 3px;
        }

        .video-status.queued {
            background: rgba(102, 102, 102, 0.2);
            color: var(--gray-light);
        }

        .video-status.processing {
            background: rgba(0, 170, 255, 0.2);
            color: #00aaff;
        }

        .video-status.completed {
            background: rgba(0, 170, 0, 0.2);
            color: #00aa00;
        }

        .video-status.failed {
            background: rgba(255, 0, 0, 0.2);
            color: #ff0000;
        }

        .progress-bar-cell {
            width: 150px;
        }

        .video-progress-bar {
            width: 100%;
            height: 4px;
            background: var(--gray-medium);
            position: relative;
            overflow: hidden;
        }

        .video-progress-fill {
            height: 100%;
            background: var(--white);
            transition: width 0.3s ease;
        }

        .video-actions {
            display: flex;
            gap: 10px;
        }

        .icon-btn {
            background: none;
            border: none;
            color: var(--gray-light);
            cursor: pointer;
            padding: 8px 12px;
            font-size: 1.4em;
            transition: all 0.2s;
            line-height: 1;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 36px;
        }

        .icon-btn:hover {
            color: var(--white);
            transform: scale(1.15);
        }

        .batch-summary {
            display: flex;
            gap: 30px;
            padding: 20px 0;
            border-top: 1px solid var(--gray-medium);
            margin-top: 20px;
        }

        .summary-item {
            flex: 1;
        }

        .summary-label {
            font-size: 0.7em;
            color: var(--gray-light);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 8px;
        }

        .summary-value {
            font-size: 1.8em;
            font-weight: 300;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--gray-light);
        }

        .empty-state-icon {
            font-size: 3em;
            margin-bottom: 20px;
            opacity: 0.3;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .sidebar {
                width: 60px;
            }

            .sidebar:hover {
                width: 200px;
            }

            .sidebar-brand-icon {
                font-size: 1em;
            }

            .main-content {
                margin-left: 60px;
                padding: 30px 20px;
                width: calc(100% - 60px);
            }

            .panel {
                padding: 20px;
            }

            .criteria-grid {
                grid-template-columns: 1fr;
            }

            .criteria-analysis-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .model-contribution-grid {
                grid-template-columns: 1fr;
            }

            .pipeline-stages {
                padding: 20px;
                overflow-x: scroll;
                justify-content: flex-start;
                gap: 60px;
            }

            .pipeline-stage:not(:last-child)::after {
                right: -60px;
            }

            .stage-name {
                font-size: 0.65em;
            }
        }
    </style>
</head>
<body>
    <!-- Sidebar Navigation -->
    <div class="sidebar">
        <div class="sidebar-brand">
            <span class="sidebar-brand-icon">◆</span>
            <span class="sidebar-brand-text">SAFEVID</span>
        </div>
        <nav class="sidebar-nav">
            <a href="#" class="sidebar-link active" data-tab="pipeline" data-label="Pipeline">
                <span class="sidebar-icon">▶</span>
                <span class="sidebar-text">PIPELINE</span>
            </a>
            <a href="#" class="sidebar-link" data-tab="live-feed" data-label="Live Feed">
                <span class="sidebar-icon">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <circle cx="12" cy="12" r="2" fill="red"></circle>
                        <path d="M23 7l-7 5 7 5V7z"></path>
                        <rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
                    </svg>
                </span>
                <span class="sidebar-text">LIVE FEED</span>
            </a>
            <a href="#" class="sidebar-link" data-tab="live-events" data-label="Live Events">
                <span class="sidebar-icon">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="3"></circle>
                        <path d="M12 1v6m0 6v6m11-7h-6M7 12H1"></path>
                    </svg>
                </span>
                <span class="sidebar-text">LIVE EVENTS</span>
            </a>
            <a href="#" class="sidebar-link" data-tab="analytics" data-label="Analytics">
                <span class="sidebar-icon">◧</span>
                <span class="sidebar-text">ANALYTICS</span>
            </a>
            <a href="#" class="sidebar-link" data-tab="settings" data-label="Settings">
                <span class="sidebar-icon">⚙</span>
                <span class="sidebar-text">SETTINGS</span>
            </a>
        </nav>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <div class="container">
        <!-- PIPELINE TAB -->
        <div id="pipeline" class="tab-content active">
        
        <!-- Batch Upload & Queue Panel -->
        <div class="panel" id="batchPanel">
            <div class="panel-header">
                <div class="panel-title">VIDEO EVALUATION QUEUE</div>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button class="icon-btn" id="addVideosBtn" title="Add Videos" style="font-size: 1.5em; padding: 8px 16px; border: 1px solid var(--white); background: transparent; color: var(--white); cursor: pointer; transition: all 0.3s;">+</button>
                    <button class="icon-btn" id="liveFeedBtn" title="Live Camera/Stream" style="font-size: 1.3em; padding: 8px 16px; border: 1px solid var(--white); background: transparent; color: var(--white); cursor: pointer; transition: all 0.3s;">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M23 7l-7 5 7 5V7z"></path>
                            <rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
                        </svg>
                    </button>
                    <input type="file" id="batchFileInput" multiple accept="video/*,.zip" style="display: none;">
                    <button class="btn" id="processAllBtn" disabled>▶ PROCESS ALL</button>
                    <button class="btn" id="clearCompletedBtn" style="display: none;">CLEAR COMPLETED</button>
                </div>
            </div>
            
            <!-- Data Source Selection Modal -->
            <div id="dataSourceModal" class="modal" style="display: none;">
                <div class="modal-content" style="max-width: 500px;">
                    <div class="modal-header">
                        <h3 style="margin: 0; font-size: 1.1em; font-weight: 600; letter-spacing: 1px;">SELECT DATA SOURCE</h3>
                        <button class="close-btn" onclick="closeDataSourceModal()">×</button>
                    </div>
                    <div class="modal-body" style="padding: 30px;">
                        <div class="data-source-options">
                            <div class="data-source-option" onclick="selectDataSource('local')">
                                <div class="source-icon">⬆</div>
                                <div class="source-info">
                                    <div class="source-title">LOCAL FILES</div>
                                    <div class="source-description">Upload videos from your computer</div>
                                </div>
                            </div>
                            
                            <div class="data-source-option" onclick="selectDataSource('storage')">
                                <div class="source-icon">☁</div>
                                <div class="source-info">
                                    <div class="source-title">CLOUD STORAGE</div>
                                    <div class="source-description">Import from S3, GCS, or Azure</div>
                                </div>
                            </div>
                            
                            <div class="data-source-option" onclick="selectDataSource('database')">
                                <div class="source-icon">▦</div>
                                <div class="source-info">
                                    <div class="source-title">DATABASE</div>
                                    <div class="source-description">Fetch videos from connected database</div>
                                </div>
                            </div>
                            
                            <div class="data-source-option" onclick="selectDataSource('url')">
                                <div class="source-icon">⎘</div>
                                <div class="source-info">
                                    <div class="source-title">URL</div>
                                    <div class="source-description">Import videos from URLs</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Storage Source Configuration Modal -->
            <div id="storageConfigModal" class="modal" style="display: none;">
                <div class="modal-content" style="max-width: 600px;">
                    <div class="modal-header">
                        <h3 style="margin: 0; font-size: 1.1em; font-weight: 600; letter-spacing: 1px;">CLOUD STORAGE CONFIGURATION</h3>
                        <button class="close-btn" onclick="closeStorageConfigModal()">×</button>
                    </div>
                    <div class="modal-body" style="padding: 30px;">
                        <div class="form-group">
                            <label>Storage Provider</label>
                            <select id="storageProvider" class="form-input">
                                <option value="s3">Amazon S3</option>
                                <option value="gcs">Google Cloud Storage</option>
                                <option value="azure">Azure Blob Storage</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Bucket/Container Name</label>
                            <input type="text" id="storageBucket" class="form-input" placeholder="my-video-bucket">
                        </div>
                        <div class="form-group">
                            <label>File Path/Prefix (optional)</label>
                            <input type="text" id="storagePath" class="form-input" placeholder="videos/">
                        </div>
                        <div class="form-group">
                            <label>Access Key/Credentials</label>
                            <input type="password" id="storageCredentials" class="form-input" placeholder="Enter credentials">
                        </div>
                        <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                            <button class="btn" onclick="closeStorageConfigModal()" style="background: var(--gray-medium);">CANCEL</button>
                            <button class="btn" onclick="fetchFromStorage()">FETCH VIDEOS</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Database Source Configuration Modal -->
            <div id="databaseConfigModal" class="modal" style="display: none;">
                <div class="modal-content" style="max-width: 600px;">
                    <div class="modal-header">
                        <h3 style="margin: 0; font-size: 1.1em; font-weight: 600; letter-spacing: 1px;">DATABASE CONFIGURATION</h3>
                        <button class="close-btn" onclick="closeDatabaseConfigModal()">×</button>
                    </div>
                    <div class="modal-body" style="padding: 30px;">
                        <div class="form-group">
                            <label>Database Type</label>
                            <select id="databaseType" class="form-input">
                                <option value="postgres">PostgreSQL</option>
                                <option value="mysql">MySQL</option>
                                <option value="mongodb">MongoDB</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Connection String</label>
                            <input type="text" id="databaseConnection" class="form-input" placeholder="postgresql://user:pass@host:5432/db">
                        </div>
                        <div class="form-group">
                            <label>Query/Collection</label>
                            <textarea id="databaseQuery" class="form-input" rows="4" placeholder="SELECT video_path FROM videos WHERE status = 'pending'"></textarea>
                        </div>
                        <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                            <button class="btn" onclick="closeDatabaseConfigModal()" style="background: var(--gray-medium);">CANCEL</button>
                            <button class="btn" onclick="fetchFromDatabase()">FETCH VIDEOS</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- URL Source Configuration Modal -->
            <div id="urlConfigModal" class="modal" style="display: none;">
                <div class="modal-content" style="max-width: 600px;">
                    <div class="modal-header">
                        <h3 style="margin: 0; font-size: 1.1em; font-weight: 600; letter-spacing: 1px;">IMPORT FROM URL</h3>
                        <button class="close-btn" onclick="closeUrlConfigModal()">×</button>
                    </div>
                    <div class="modal-body" style="padding: 30px;">
                        <div class="form-group">
                            <label>Video URLs (one per line)</label>
                            <textarea id="videoUrls" class="form-input" rows="8" placeholder="https://example.com/video1.mp4&#10;https://example.com/video2.mp4&#10;https://cdn.example.com/video3.mp4"></textarea>
                        </div>
                        <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                            <button class="btn" onclick="closeUrlConfigModal()" style="background: var(--gray-medium);">CANCEL</button>
                            <button class="btn" onclick="fetchFromUrls()">IMPORT VIDEOS</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Live Feed Modal -->
            <div id="liveFeedModal" class="modal" style="display: none;">
                <div class="modal-content" style="max-width: 700px;">
                    <div class="modal-header">
                        <h3 style="margin: 0; font-size: 1.1em; font-weight: 600; letter-spacing: 1px;">LIVE CAMERA / STREAM FEED</h3>
                        <button class="close-btn" onclick="closeLiveFeedModal()">×</button>
                    </div>
                    <div class="modal-body" style="padding: 30px;">
                        <!-- Feed Type Selection -->
                        <div class="form-group">
                            <label>Feed Type</label>
                            <select id="liveFeedType" class="form-input" onchange="toggleLiveFeedOptions()">
                                <option value="webcam">Webcam / Local Camera</option>
                                <option value="rtsp">RTSP Stream</option>
                                <option value="rtmp">RTMP Stream</option>
                                <option value="http">HTTP Live Stream (HLS/DASH)</option>
                            </select>
                        </div>
                        
                        <!-- Webcam Options -->
                        <div id="webcamOptions" class="form-group">
                            <label>Camera Device</label>
                            <select id="cameraDevice" class="form-input">
                                <option value="user">Front Camera</option>
                                <option value="environment">Back Camera (Mobile)</option>
                            </select>
                        </div>
                        
                        <!-- Stream URL Options (hidden by default) -->
                        <div id="streamUrlOptions" class="form-group" style="display: none;">
                            <label>Stream URL</label>
                            <input type="text" id="streamUrl" class="form-input" placeholder="rtsp://camera.example.com:554/stream">
                            <div style="font-size: 0.8em; color: var(--gray-light); margin-top: 5px;">
                                Examples:<br>
                                • RTSP: rtsp://username:password@192.168.1.100:554/stream<br>
                                • RTMP: rtmp://live.example.com/app/streamkey<br>
                                • HLS: https://example.com/stream/index.m3u8
                            </div>
                        </div>
                        
                        <!-- Processing Options -->
                        <div class="form-group">
                            <label>Processing Mode</label>
                            <select id="liveProcessingMode" class="form-input" onchange="toggleIntervalOptions()">
                                <option value="continuous">Continuous (Real-time analysis)</option>
                                <option value="interval">Interval (Analyze every N seconds)</option>
                                <option value="motion">Motion Triggered (Analyze when motion detected)</option>
                            </select>
                        </div>
                        
                        <div id="intervalOptions" class="form-group" style="display: none;">
                            <label>Analysis Interval (seconds)</label>
                            <input type="number" id="analysisInterval" class="form-input" value="5" min="1" max="60">
                        </div>
                        
                        <!-- Auto-save Events Option (Compact) -->
                        <div style="margin-top: 15px; padding: 12px; background: var(--gray-dark); border-radius: 4px;">
                            <label style="display: flex; align-items: center; cursor: pointer; margin: 0;">
                                <input type="checkbox" id="autoSaveEvents" checked style="margin-right: 10px; width: 16px; height: 16px;">
                                <span style="font-size: 0.9em;">Automatically save events to Live Events tab</span>
                            </label>
                        </div>
                        
                        <!-- Live Preview Area (Compact) -->
                        <div id="livePreviewArea" style="display: none; margin-top: 15px;">
                            <label style="display: block; margin-bottom: 8px; font-weight: 500; font-size: 0.9em;">Live Preview</label>
                            <div style="position: relative; background: #000; border: 1px solid var(--gray-medium); border-radius: 6px; overflow: hidden; max-height: 300px;">
                                <video id="livePreviewVideo" autoplay muted style="width: 100%; height: auto; display: block; max-height: 300px; object-fit: contain;"></video>
                                <canvas id="liveDetectionCanvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></canvas>
                            </div>
                            <div id="liveAnalysisStatus" style="margin-top: 8px; padding: 8px 12px; background: var(--gray-dark); border-radius: 4px; font-size: 0.8em; display: none;">
                                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 10px; text-align: center;">
                                    <div>
                                        <div style="font-size: 0.75em; color: var(--gray-light); margin-bottom: 2px;">STATUS</div>
                                        <strong id="liveStatusText">Idle</strong>
                                    </div>
                                    <div>
                                        <div style="font-size: 0.75em; color: var(--gray-light); margin-bottom: 2px;">FRAMES</div>
                                        <strong id="framesAnalyzed">0</strong>
                                    </div>
                                    <div>
                                        <div style="font-size: 0.75em; color: var(--gray-light); margin-bottom: 2px;">VIOLENCE</div>
                                        <strong id="liveViolenceScore">0%</strong>
                                    </div>
                                    <div>
                                        <div style="font-size: 0.75em; color: var(--gray-light); margin-bottom: 2px;">OBJECTS</div>
                                        <strong id="liveObjectCount">0</strong>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Action Buttons -->
                        <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                            <button class="btn" onclick="closeLiveFeedModal()" style="background: var(--gray-medium);">CANCEL</button>
                            <button class="btn" id="startLiveFeedBtn" onclick="startLiveFeed()">START LIVE FEED</button>
                            <button class="btn" id="stopLiveFeedBtn" onclick="stopLiveFeed()" style="display: none; background: #ff0000;">STOP FEED</button>
                        </div>
                    </div>
                </div>
            </div>
            
            
            <!-- Empty State -->
            <div class="empty-state" id="emptyState">
                <div class="empty-state-icon">▤</div>
                <div style="font-size: 0.9em; margin-bottom: 10px;">No videos in queue</div>
                <div style="font-size: 0.75em;">
                    Add videos above to start batch processing
                </div>
            </div>
            
            <!-- Split Pane Layout: File Tree + Pipeline View -->
            <div id="splitPaneContainer" style="display: none;">
                <!-- Left Pane: File System Tree -->
                <div class="file-tree-pane">
                    <div class="file-tree-header">
                        <div class="file-tree-title">
                            <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" style="margin-right: 8px;">
                                <path d="M1 4.5A2.5 2.5 0 0 1 3.5 2h9A2.5 2.5 0 0 1 15 4.5v7a2.5 2.5 0 0 1-2.5 2.5h-9A2.5 2.5 0 0 1 1 11.5v-7z"/>
                            </svg>
                            <span>VIDEO QUEUE</span>
                        </div>
                        <div class="file-tree-count" id="fileTreeCount">0 videos</div>
                    </div>
                    <div class="file-tree-content" id="fileTreeContent">
                        <!-- Populated dynamically -->
                    </div>
                </div>
                
                <!-- Right Pane: Pipeline View -->
                <div class="pipeline-detail-pane">
                    <!-- Empty State -->
                    <div class="pipeline-empty-state" id="pipelineEmptyState">
                        <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="opacity: 0.3;">
                            <path d="M9 12h6M12 9v6M3 12a9 9 0 1 0 18 0 9 9 0 0 0-18 0z"/>
                        </svg>
                        <div style="margin-top: 20px; font-size: 0.9em; color: var(--gray-light);">
                            Select a video to view its pipeline
                        </div>
                    </div>
                    
                    <!-- Pipeline Content (shown when video selected) -->
                    <div class="pipeline-detail-content" id="pipelineDetailContent" style="display: none;">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Individual Video Pipeline View (shown when viewing a specific video) -->
        <div class="panel" id="pipelineViewPanel" style="display: none;">
            <div class="panel-header">
                <div class="panel-title" id="pipelineVideoTitle">PIPELINE: VIDEO.MP4</div>
                <button class="btn" onclick="closePipelineView()">← BACK TO QUEUE</button>
            </div>
            <div class="step-indicator">
                <div class="step-number">STEP 3 OF 3</div>
                <div class="step-title">ANALYZING VIDEO</div>
            </div>
            
            <div class="pipeline-flow">
                <div class="pipeline-stages" id="pipelineStages">
                    <div class="pipeline-stage" data-stage="ingest_video">
                        <div class="stage-icon-wrapper">
                            <div class="stage-number">01</div>
                            <div class="stage-status">⟳</div>
                        </div>
                        <div class="stage-name">INGEST</div>
                        <div class="stage-time"></div>
                    </div>
                    <div class="pipeline-stage" data-stage="segment_video">
                        <div class="stage-icon-wrapper">
                            <div class="stage-number">02</div>
                            <div class="stage-status">⟳</div>
                        </div>
                        <div class="stage-name">SEGMENT</div>
                        <div class="stage-time"></div>
                    </div>
                    <div class="pipeline-stage" data-stage="yolo26_vision">
                        <div class="stage-icon-wrapper">
                            <div class="stage-number">03</div>
                            <div class="stage-status">⟳</div>
                        </div>
                        <div class="stage-name">VISION</div>
                        <div class="stage-time"></div>
                    </div>
                    <div class="pipeline-stage" data-stage="yoloworld_vision">
                        <div class="stage-icon-wrapper">
                            <div class="stage-number">04</div>
                            <div class="stage-status">⟳</div>
                        </div>
                        <div class="stage-name">YOLO-WORLD</div>
                        <div class="stage-time"></div>
                    </div>
                    <div class="pipeline-stage" data-stage="violence_detection">
                        <div class="stage-icon-wrapper">
                            <div class="stage-number">05</div>
                            <div class="stage-status">⟳</div>
                        </div>
                        <div class="stage-name">VIOLENCE</div>
                        <div class="stage-time"></div>
                    </div>
                    <div class="pipeline-stage" data-stage="audio_transcription">
                        <div class="stage-icon-wrapper">
                            <div class="stage-number">06</div>
                            <div class="stage-status">⟳</div>
                        </div>
                        <div class="stage-name">AUDIO</div>
                        <div class="stage-time"></div>
                    </div>
                    <div class="pipeline-stage" data-stage="ocr_extraction">
                        <div class="stage-icon-wrapper">
                            <div class="stage-number">07</div>
                            <div class="stage-status">⟳</div>
                        </div>
                        <div class="stage-name">OCR</div>
                        <div class="stage-time"></div>
                    </div>
                    <div class="pipeline-stage" data-stage="text_moderation">
                        <div class="stage-icon-wrapper">
                            <div class="stage-number">08</div>
                            <div class="stage-status">⟳</div>
                        </div>
                        <div class="stage-name">MODERATE</div>
                        <div class="stage-time"></div>
                    </div>
                    <div class="pipeline-stage" data-stage="policy_fusion">
                        <div class="stage-icon-wrapper">
                            <div class="stage-number">09</div>
                            <div class="stage-status">⟳</div>
                        </div>
                        <div class="stage-name">SCORING</div>
                        <div class="stage-time"></div>
                    </div>
                    <div class="pipeline-stage" data-stage="report_generation">
                        <div class="stage-icon-wrapper">
                            <div class="stage-number">10</div>
                            <div class="stage-status">⟳</div>
                        </div>
                        <div class="stage-name">REPORT</div>
                        <div class="stage-time"></div>
                    </div>
                    <div class="pipeline-stage" data-stage="finalize">
                        <div class="stage-icon-wrapper">
                            <div class="stage-number">11</div>
                            <div class="stage-status">⟳</div>
                        </div>
                        <div class="stage-name">FINALIZE</div>
                        <div class="stage-time"></div>
                    </div>
                </div>
                
            </div>
            
            <!-- Two-column layout: Video + Stage Output (YouTube-like) -->
            <div style="display: grid; grid-template-columns: 1fr 450px; gap: 20px; margin-top: 30px;">
                
                <!-- Left Column: Video Preview -->
                <div id="pipelineVideoPreview" style="padding: 20px; background: var(--black); border: 1px solid var(--gray-medium); display: flex; flex-direction: column; height: 556px;">
                    <div style="font-size: 0.85em; letter-spacing: 2px; color: var(--gray-light); font-weight: 500; margin-bottom: 12px; text-transform: uppercase; flex-shrink: 0;">Labeled Video Preview</div>
                    <div style="display: flex; flex-direction: column; justify-content: center; align-items: center; background: #000; flex: 1; overflow: hidden; gap: 10px;">
                        <video id="pipelineVideoPlayer" controls style="max-width: 100%; max-height: calc(100% - 40px); width: auto; height: auto; display: block; object-fit: contain;"></video>
                        
                        <!-- Custom Timeline with Violence Markers -->
                        <div id="customVideoTimeline" style="width: 90%; height: 30px; position: relative; display: none;">
                            <!-- Timeline Background -->
                            <div style="width: 100%; height: 8px; background: rgba(255,255,255,0.2); border-radius: 4px; position: relative; cursor: pointer; margin-top: 10px;" id="timelineTrack">
                                <!-- Progress Bar (behind markers) -->
                                <div id="timelineProgress" style="position: absolute; top: 0; left: 0; height: 100%; background: rgba(255,255,255,0.4); border-radius: 4px; width: 0%; pointer-events: none; z-index: 1;"></div>
                                
                                <!-- Violence Markers Container (in front) -->
                                <div id="violenceMarkersContainer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none;"></div>
                            </div>
                            
                            <!-- Time Display -->
                            <div style="display: flex; justify-content: space-between; margin-top: 5px; font-size: 0.75em; color: var(--gray-light);">
                                <span id="currentTimeDisplay">0:00</span>
                                <span id="durationDisplay">0:00</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Right Column: Stage Output (always visible sidebar, fixed height with scroll) -->
                <div id="stageOutputSection" style="padding: 20px; background: var(--gray-dark); border: 1px solid var(--gray-medium); display: flex; flex-direction: column; overflow: hidden; height: 556px;">
                    <div style="margin-bottom: 15px; flex-shrink: 0;">
                        <div id="stageOutputTitle" style="font-size: 0.9em; letter-spacing: 1px; color: var(--white); font-weight: 500;">STAGE DETAILS</div>
                    </div>
                    <div style="flex: 1; overflow-y: auto; overflow-x: hidden; padding-right: 8px;">
                        <div id="stageOutputContent" style="color: var(--gray-light); word-wrap: break-word; overflow-wrap: break-word; word-break: break-word; max-width: 100%;">
                            <div style="text-align: center; padding: 60px 20px; color: var(--gray-medium);">
                                <div style="font-size: 2em; margin-bottom: 15px;">←</div>
                                <div style="font-size: 0.9em; line-height: 1.6;">
                                    Click any stage in the pipeline above to view detailed output and evidence.
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
            </div>
            
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>

        <!-- Video Preview Modal (moved outside pipelineViewPanel to be accessible from all tabs) -->
        <div id="videoPreviewModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.92); z-index: 10000; padding: 20px;">
            <div style="position: relative; width: 100%; max-width: 800px; background: var(--gray-dark); padding: 20px; border: 1px solid var(--gray-medium); margin: 0 auto; margin-top: 5vh;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <div id="previewTitle" style="font-size: 0.9em; letter-spacing: 1px; color: var(--white); font-weight: 500;">VIDEO PREVIEW</div>
                    <button onclick="closeVideoPreview()" style="background: transparent; border: 1px solid var(--white); color: var(--white); padding: 6px 12px; cursor: pointer; font-size: 0.8em; transition: all 0.3s;">
                        ✕ CLOSE
                    </button>
                </div>
                
                <div style="background: var(--black); padding: 0; margin-bottom: 12px; width: 100%; height: 400px; display: flex; align-items: center; justify-content: center; overflow: hidden;">
                    <video id="previewVideo" controls style="max-width: 100%; max-height: 100%; width: auto; height: auto; object-fit: contain; background: #000;"></video>
                </div>
                
                <div id="previewInfo" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; color: var(--gray-light); font-size: 0.8em;">
                    <!-- Video info will be populated here -->
                </div>
            </div>
        </div>

        <!-- Error Display -->
        <div class="error-display" id="errorDisplay">
            <div class="error-title">ERROR</div>
            <div class="error-message" id="errorMessage"></div>
        </div>

        </div>
        <!-- END PIPELINE TAB -->

        <!-- ANALYTICS TAB -->
        <div id="analytics" class="tab-content">
            <!-- Batch Analytics View (shown when no specific video selected) -->
            <div id="batchAnalytics">
                <div class="panel">
                    <div class="panel-header">
                        <div class="panel-title">CURRENT BATCH SUMMARY</div>
                    </div>
                    <div style="padding: 30px;">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px;">
                            <div style="background: var(--gray-dark); padding: 20px; border-left: 3px solid var(--white);">
                                <div style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 8px;">TOTAL VIDEOS</div>
                                <div style="font-size: 2em; font-weight: 500;" id="analyticsTotal">0</div>
                            </div>
                            <div style="background: var(--gray-dark); padding: 20px; border-left: 3px solid #00aa00;">
                                <div style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 8px;">SAFE</div>
                                <div style="font-size: 2em; font-weight: 500; color: #00aa00;" id="analyticsSafe">0</div>
                            </div>
                            <div style="background: var(--gray-dark); padding: 20px; border-left: 3px solid #ffaa00;">
                                <div style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 8px;">CAUTION</div>
                                <div style="font-size: 2em; font-weight: 500; color: #ffaa00;" id="analyticsCaution">0</div>
                            </div>
                            <div style="background: var(--gray-dark); padding: 20px; border-left: 3px solid #ff0000;">
                                <div style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 8px;">UNSAFE</div>
                                <div style="font-size: 2em; font-weight: 500; color: #ff0000;" id="analyticsUnsafe">0</div>
                            </div>
                        </div>

                        <div id="batchAnalyticsEmpty" style="text-align: center; padding: 60px; color: var(--gray-light);">
                            <div style="font-size: 3em; margin-bottom: 15px;">◧</div>
                            <div style="font-size: 1.1em; margin-bottom: 10px;">NO BATCH DATA YET</div>
                            <div style="font-size: 0.85em;">Process videos to see aggregate analytics</div>
                        </div>

                        <div id="batchAnalyticsContent" style="display: none;">
                            <!-- Criteria Breakdown -->
                            <div style="margin-top: 30px;">
                                <div style="font-size: 0.9em; font-weight: 500; margin-bottom: 15px; letter-spacing: 1px;">VIOLATIONS BREAKDOWN</div>
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;" id="criteriaBreakdown">
                                    <!-- Populated dynamically -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Individual Video Analytics View (shown when viewing specific video) -->
            <div id="analyticsResults" style="display: none;">
                
                <!-- Top Section: Verdict + Video Side by Side -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                    <!-- Left: Verdict and Stats -->
                    <div class="panel" style="background: var(--gray-dark); border: 2px solid var(--white);">
                        <div class="verdict-display" style="padding: 40px 30px;">
                            <div class="verdict-label">FINAL VERDICT</div>
                            <div class="verdict-badge" id="verdictBadge" style="font-size: 3em; margin: 20px 0;">SAFE</div>
                            <div id="verdictDescription" style="color: var(--gray-light); font-size: 0.9em; text-align: center; margin-top: 15px;"></div>
                        </div>
                        <div style="border-top: 1px solid var(--gray-medium); padding: 20px;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;" id="statsGrid"></div>
                        </div>
                    </div>

                    <!-- Right: Video Player -->
                    <div class="panel">
                        <div class="video-container compact" id="videoContainer">
                            <div class="video-controls">
                                <button class="video-control-btn" id="expandVideoBtn" onclick="toggleVideoSize()">
                                    ⛶ EXPAND
                                </button>
                            </div>
                            <video id="videoPlayer" controls></video>
                            <div class="video-timeline-wrapper">
                                <div class="video-timeline-markers" id="timelineMarkers"></div>
                            </div>
                            <div class="timeline-legend">
                                <span>■</span> Violation timestamps
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Safety Criteria Scores -->
                <div class="panel">
                    <div class="panel-header">
                        <div class="panel-title">SAFETY ANALYSIS</div>
                    </div>
                    <div style="padding: 30px;">
                        <div id="criteriaGrid" class="criteria-analysis-grid"></div>
                    </div>
                </div>

                <!-- Model Contributions -->
                <div class="panel">
                    <div class="panel-header">
                        <div class="panel-title">MODEL CONTRIBUTIONS</div>
                        <div style="font-size: 0.7em; color: var(--gray-light); font-weight: 300;">How each detection model influenced the final scores</div>
                    </div>
                    <div style="padding: 30px;" id="modelContributions">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>

                <!-- Violations Timeline -->
                <div class="panel" id="violationsPanel" style="display: none;">
                    <div class="panel-header">
                        <div class="panel-title">VIOLATIONS TIMELINE</div>
                    </div>
                    <div class="violations-timeline" id="violationsList"></div>
                </div>

                <!-- AI Summary Report -->
                <div class="panel" style="border: 2px solid var(--white); box-shadow: 0 0 20px rgba(255,255,255,0.1);">
                    <div class="panel-header" style="background: var(--gray-dark); border-bottom: 2px solid var(--white);">
                        <div class="panel-title" style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-size: 1.2em;">🤖</span>
                            AI SUMMARY
                            <span style="font-size: 0.65em; color: var(--gray-light); font-weight: 300; letter-spacing: 1px; margin-left: auto;">POWERED BY GPT</span>
                        </div>
                    </div>
                    <div class="report-content" id="reportContent">
                        <div style="text-align: center; color: var(--gray-light); padding: 20px;">
                            Generating AI summary...
                        </div>
                    </div>
                </div>

                <!-- Actions -->
                <div style="display: flex; gap: 15px; margin-top: 30px; justify-content: center;">
                    <button class="btn" style="background: #00aa00; color: var(--white); border-color: #00aa00; min-width: 150px;" onclick="approveVideo()">
                        ✓ APPROVE
                    </button>
                    <button class="btn" style="background: #ff0000; color: var(--white); border-color: #ff0000; min-width: 150px;" onclick="flagVideo()">
                        ⚠ FLAG
                    </button>
                    <button class="btn" style="min-width: 150px;" onclick="exportResults()">
                        ↓ EXPORT
                    </button>
                    <button class="btn" style="min-width: 150px;" onclick="resetAnalysis()">
                        ↻ NEW ANALYSIS
                    </button>
                </div>
            </div>
            <!-- END ANALYTICS RESULTS -->
        </div>
        <!-- END ANALYTICS TAB -->

        <!-- LIVE FEED TAB -->
        <div id="live-feed" class="tab-content">
            <!-- Feed Controls (Compact, always visible) -->
            <div style="background: var(--gray-dark); padding: 15px 20px; border-radius: 8px; margin-bottom: 20px;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; align-items: end;">
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-size: 0.75em; color: var(--gray-light); text-transform: uppercase;">Feed Type</label>
                        <select id="liveFeedTypeTab" class="form-input" style="padding: 8px;">
                            <option value="webcam">Webcam / Local Camera</option>
                            <option value="rtsp">RTSP Stream</option>
                            <option value="rtmp">RTMP Stream</option>
                            <option value="http">HTTP Live Stream</option>
                        </select>
                    </div>
                    <div id="webcamOptionsTab">
                        <label style="display: block; margin-bottom: 5px; font-size: 0.75em; color: var(--gray-light); text-transform: uppercase;">Camera</label>
                        <select id="cameraDeviceTab" class="form-input" style="padding: 8px;">
                            <option value="user">Front Camera</option>
                            <option value="environment">Back Camera</option>
                        </select>
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-size: 0.75em; color: var(--gray-light); text-transform: uppercase;">Processing</label>
                        <select id="liveProcessingModeTab" class="form-input" style="padding: 8px;">
                            <option value="continuous">Continuous</option>
                            <option value="interval">Interval (5s)</option>
                        </select>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn" id="startLiveFeedTabBtn" onclick="startLiveFeedTab()" style="flex: 1; padding: 8px 16px;">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 5px;">
                                <polygon points="5 3 19 12 5 21 5 3"></polygon>
                            </svg>
                            START
                        </button>
                        <button class="btn" id="stopLiveFeedTabBtn" onclick="stopLiveFeedTab()" style="flex: 1; background: #ff0000; padding: 8px 16px; display: none;">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 5px;">
                                <rect width="18" height="18" x="3" y="3"></rect>
                            </svg>
                            STOP
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Live Feed View (Grid Layout) -->
            <div id="liveFeedViewArea" style="display: none;">
                <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 20px; margin-bottom: 20px;">
                    <!-- Left: Video Preview -->
                    <div style="background: var(--gray-dark); border-radius: 8px; overflow: hidden;">
                        <div style="padding: 15px; border-bottom: 1px solid var(--gray-medium);">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="font-weight: 600; letter-spacing: 1px;">VIDEO FEED</div>
                                <div id="liveIndicator" style="display: flex; align-items: center; gap: 8px; color: #ff0000;">
                                    <span style="width: 8px; height: 8px; background: #ff0000; border-radius: 50%; animation: pulse 1.5s infinite;"></span>
                                    <span style="font-size: 0.85em; font-weight: 600;">LIVE</span>
                                </div>
                            </div>
                        </div>
                        <div style="position: relative; background: #000; height: 480px; border-radius: 4px; overflow: hidden;">
                            <video id="livePreviewVideoTab" autoplay muted playsinline style="width: 100%; height: 100%; object-fit: contain;"></video>
                            <canvas id="liveDetectionCanvasTab" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></canvas>
                        </div>
                    </div>
                    
                    <!-- Right: Real-time Stats -->
                    <div>
                        <!-- Status Cards -->
                        <div style="display: grid; gap: 12px; margin-bottom: 15px;">
                            <div style="background: var(--gray-dark); padding: 15px; border-radius: 8px; text-align: center;">
                                <div style="font-size: 0.75em; color: var(--gray-light); margin-bottom: 5px;">STATUS</div>
                                <div id="liveStatusTextTab" style="font-size: 1.3em; font-weight: 600; color: #00aa00;">Analyzing...</div>
                            </div>
                            <div style="background: var(--gray-dark); padding: 15px; border-radius: 8px; text-align: center;">
                                <div style="font-size: 0.75em; color: var(--gray-light); margin-bottom: 5px;">FRAMES ANALYZED</div>
                                <div id="framesAnalyzedTab" style="font-size: 2em; font-weight: 300;">0</div>
                            </div>
                            <div style="background: var(--gray-dark); padding: 15px; border-radius: 8px; text-align: center;">
                                <div style="font-size: 0.75em; color: var(--gray-light); margin-bottom: 5px;">VIOLENCE SCORE</div>
                                <div id="liveViolenceScoreTab" style="font-size: 2em; font-weight: 300; color: #00aa00;">0%</div>
                            </div>
                            <div style="background: var(--gray-dark); padding: 15px; border-radius: 8px; text-align: center;">
                                <div style="font-size: 0.75em; color: var(--gray-light); margin-bottom: 5px;">OBJECTS DETECTED</div>
                                <div id="liveObjectCountTab" style="font-size: 2em; font-weight: 300;">0</div>
                            </div>
                        </div>
                        
                        <!-- Latest Detections -->
                        <div style="background: var(--gray-dark); padding: 15px; border-radius: 8px;">
                            <div style="font-weight: 600; margin-bottom: 10px; font-size: 0.85em; letter-spacing: 1px;">LATEST DETECTIONS</div>
                            <div id="latestDetections" style="max-height: 200px; overflow-y: auto; font-size: 0.85em;">
                                <div style="color: var(--gray-light); text-align: center; padding: 20px;">No detections yet</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Recent Events Stream -->
                <div style="background: var(--gray-dark); padding: 15px; border-radius: 8px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <div style="font-weight: 600; letter-spacing: 1px;">RECENT EVENTS</div>
                        <button class="btn" onclick="viewAllLiveEvents()" style="padding: 6px 12px; font-size: 0.85em; background: transparent; border: 1px solid var(--gray-medium);">
                            VIEW ALL →
                        </button>
                    </div>
                    <div id="recentEventsStream" style="display: flex; gap: 12px; overflow-x: auto; padding: 5px;">
                        <div style="color: var(--gray-light); text-align: center; padding: 30px; width: 100%;">No events captured yet</div>
                    </div>
                </div>
            </div>
            
            <!-- Empty State (when feed not started) -->
            <div id="liveFeedEmptyState" class="empty-state">
                <div style="font-size: 3em; margin-bottom: 15px;">📹</div>
                <div style="font-size: 1.1em; margin-bottom: 10px;">No Live Feed Active</div>
                <div style="font-size: 0.85em; color: var(--gray-light);">
                    Configure your feed source above and click START to begin live monitoring
                </div>
            </div>
        </div>

        <!-- SETTINGS TAB -->
        <div id="settings" class="tab-content">
            <div class="panel">
                <div class="panel-header">
                    <div class="panel-title">POLICY CONFIGURATION</div>
                </div>
                <div class="panel-body" style="max-width: 900px; margin: 0 auto;">
                    
                    <!-- Policy Preset Section -->
                    <div style="background: var(--gray-darker); padding: 25px; border-radius: 8px; margin-bottom: 30px;">
                        <h3 style="font-size: 0.95em; font-weight: 600; margin-bottom: 15px; color: var(--white);">POLICY PRESET</h3>
                        <select id="policyPresetTab" class="form-input" onchange="loadPolicyPreset(this.value)" style="width: 100%; padding: 12px; font-size: 0.95em;">
                            <option value="balanced">Balanced (Default) - Moderate flagging</option>
                            <option value="strict">Strict (High Sensitivity) - Maximum protection</option>
                            <option value="lenient">Lenient (Low Sensitivity) - Reduced false positives</option>
                            <option value="custom">Custom - Manually configured</option>
                        </select>
                        <div style="margin-top: 15px; padding: 12px; background: var(--gray-dark); border-left: 3px solid var(--blue); font-size: 0.85em; color: var(--gray-light);">
                            <strong>Note:</strong> Policy changes apply to all new video processing. Existing results are not affected.
                        </div>
                    </div>
                    
                    <!-- Unsafe Thresholds Section -->
                    <div style="background: var(--gray-darker); padding: 25px; border-radius: 8px; margin-bottom: 30px;">
                        <h3 style="font-size: 0.95em; font-weight: 600; margin-bottom: 5px; color: var(--white);">UNSAFE THRESHOLDS</h3>
                        <p style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 20px;">Videos exceeding these thresholds will be marked as UNSAFE</p>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                            <div class="form-group">
                                <label style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                                    <span>Violence</span>
                                    <span id="unsafeViolenceValue" style="color: var(--red); font-weight: 600;">0.75</span>
                                </label>
                                <input type="range" id="unsafeViolenceTab" class="form-range" min="0" max="1" step="0.05" value="0.75" oninput="updateThresholdDisplay('unsafeViolence', this.value)">
                            </div>
                            
                            <div class="form-group">
                                <label style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                                    <span>Sexual Content</span>
                                    <span id="unsafeSexualValue" style="color: var(--red); font-weight: 600;">0.60</span>
                                </label>
                                <input type="range" id="unsafeSexualTab" class="form-range" min="0" max="1" step="0.05" value="0.60" oninput="updateThresholdDisplay('unsafeSexual', this.value)">
                            </div>
                            
                            <div class="form-group">
                                <label style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                                    <span>Hate Speech</span>
                                    <span id="unsafeHateValue" style="color: var(--red); font-weight: 600;">0.60</span>
                                </label>
                                <input type="range" id="unsafeHateTab" class="form-range" min="0" max="1" step="0.05" value="0.60" oninput="updateThresholdDisplay('unsafeHate', this.value)">
                            </div>
                            
                            <div class="form-group">
                                <label style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                                    <span>Drugs/Substances</span>
                                    <span id="unsafeDrugsValue" style="color: var(--red); font-weight: 600;">0.70</span>
                                </label>
                                <input type="range" id="unsafeDrugsTab" class="form-range" min="0" max="1" step="0.05" value="0.70" oninput="updateThresholdDisplay('unsafeDrugs', this.value)">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Caution Thresholds Section -->
                    <div style="background: var(--gray-darker); padding: 25px; border-radius: 8px; margin-bottom: 30px;">
                        <h3 style="font-size: 0.95em; font-weight: 600; margin-bottom: 5px; color: var(--white);">CAUTION THRESHOLDS</h3>
                        <p style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 20px;">Videos exceeding these thresholds will be marked as CAUTION</p>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                            <div class="form-group">
                                <label style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                                    <span>Violence</span>
                                    <span id="cautionViolenceValue" style="color: var(--orange); font-weight: 600;">0.40</span>
                                </label>
                                <input type="range" id="cautionViolenceTab" class="form-range" min="0" max="1" step="0.05" value="0.40" oninput="updateThresholdDisplay('cautionViolence', this.value)">
                            </div>
                            
                            <div class="form-group">
                                <label style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                                    <span>Profanity</span>
                                    <span id="cautionProfanityValue" style="color: var(--orange); font-weight: 600;">0.40</span>
                                </label>
                                <input type="range" id="cautionProfanityTab" class="form-range" min="0" max="1" step="0.05" value="0.40" oninput="updateThresholdDisplay('cautionProfanity', this.value)">
                            </div>
                            
                            <div class="form-group">
                                <label style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                                    <span>Drugs</span>
                                    <span id="cautionDrugsValue" style="color: var(--orange); font-weight: 600;">0.40</span>
                                </label>
                                <input type="range" id="cautionDrugsTab" class="form-range" min="0" max="1" step="0.05" value="0.40" oninput="updateThresholdDisplay('cautionDrugs', this.value)">
                            </div>
                            
                            <div class="form-group">
                                <label style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                                    <span>Sexual Content</span>
                                    <span id="cautionSexualValue" style="color: var(--orange); font-weight: 600;">0.30</span>
                                </label>
                                <input type="range" id="cautionSexualTab" class="form-range" min="0" max="1" step="0.05" value="0.30" oninput="updateThresholdDisplay('cautionSexual', this.value)">
                            </div>
                            
                            <div class="form-group">
                                <label style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                                    <span>Hate Speech</span>
                                    <span id="cautionHateValue" style="color: var(--orange); font-weight: 600;">0.30</span>
                                </label>
                                <input type="range" id="cautionHateTab" class="form-range" min="0" max="1" step="0.05" value="0.30" oninput="updateThresholdDisplay('cautionHate', this.value)">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Action Buttons -->
                    <div style="display: flex; gap: 15px; justify-content: flex-end;">
                        <button class="btn" onclick="resetPolicyToDefault()" style="background: var(--gray-medium); padding: 12px 24px;">
                            <span style="margin-right: 5px;">↺</span> RESET TO DEFAULT
                        </button>
                        <button class="btn" onclick="savePolicySettings()" style="padding: 12px 32px;">
                            <span style="margin-right: 5px;">✓</span> APPLY POLICY
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- LIVE EVENTS TAB -->
        <div id="live-events" class="tab-content">
            <!-- Filters -->
            <div style="background: var(--gray-dark); padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                <div style="display: flex; gap: 20px; align-items: center; flex-wrap: wrap;">
                    <div style="flex: 1; min-width: 200px;">
                        <label style="display: block; margin-bottom: 8px; font-size: 0.85em; color: var(--gray-light);">FILTER BY SEVERITY</label>
                        <select id="liveEventsFilter" class="form-input" onchange="filterLiveEvents()" style="width: 100%;">
                            <option value="all">All Events</option>
                            <option value="violations">Violations Only</option>
                            <option value="high-violence">High Violence (>70%)</option>
                            <option value="weapons">Weapons Detected</option>
                            <option value="safe">Safe Only</option>
                        </select>
                    </div>
                    <div style="flex: 1; min-width: 200px;">
                        <label style="display: block; margin-bottom: 8px; font-size: 0.85em; color: var(--gray-light);">STREAM</label>
                        <select id="liveEventsStream" class="form-input" onchange="filterLiveEvents()" style="width: 100%;">
                            <option value="all">All Streams</option>
                        </select>
                    </div>
                    <div style="display: flex; gap: 10px; align-items: flex-end;">
                        <button class="btn" onclick="refreshLiveEvents()" style="padding: 10px 20px;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 5px;">
                                <path d="M1 4v6h6M23 20v-6h-6"></path>
                                <path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path>
                            </svg>
                            REFRESH
                        </button>
                        <button class="btn" onclick="clearLiveEvents()" style="background: #ff0000; padding: 10px 20px;">CLEAR ALL</button>
                    </div>
                </div>
            </div>
            
            <!-- Stats Summary -->
            <div id="liveEventsStats" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                <div style="background: var(--gray-dark); padding: 20px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 2em; font-weight: 300; margin-bottom: 5px;" id="totalLiveEvents">0</div>
                    <div style="font-size: 0.85em; color: var(--gray-light); letter-spacing: 1px;">TOTAL EVENTS</div>
                </div>
                <div style="background: var(--gray-dark); padding: 20px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 2em; font-weight: 300; margin-bottom: 5px; color: #ff0000;" id="totalViolations">0</div>
                    <div style="font-size: 0.85em; color: var(--gray-light); letter-spacing: 1px;">VIOLATIONS</div>
                </div>
                <div style="background: var(--gray-dark); padding: 20px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 2em; font-weight: 300; margin-bottom: 5px; color: #00aa00;" id="totalSafe">0</div>
                    <div style="font-size: 0.85em; color: var(--gray-light); letter-spacing: 1px;">SAFE</div>
                </div>
                <div style="background: var(--gray-dark); padding: 20px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 2em; font-weight: 300; margin-bottom: 5px;" id="avgViolenceScore">0%</div>
                    <div style="font-size: 0.85em; color: var(--gray-light); letter-spacing: 1px;">AVG VIOLENCE</div>
                </div>
            </div>
            
            <!-- Events Table -->
            <div class="panel">
                <div class="panel-header">
                    <div class="panel-title">CAPTURED EVENTS</div>
                    <div id="liveEventsCount" style="color: var(--gray-light); font-size: 0.9em;">0 events</div>
                </div>
                
                <div id="liveEventsTableContainer" style="overflow-x: auto;">
                    <table class="videos-table" style="width: 100%;">
                        <thead>
                            <tr>
                                <th style="width: 100px;">Thumbnail</th>
                                <th>Time</th>
                                <th>Stream</th>
                                <th>Violence</th>
                                <th>Objects</th>
                                <th>Status</th>
                                <th style="text-align: center;">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="liveEventsTableBody">
                            <tr>
                                <td colspan="7" style="text-align: center; padding: 40px; color: var(--gray-light);">
                                    <div style="font-size: 1.2em; margin-bottom: 10px;">No live events captured yet</div>
                                    <div style="font-size: 0.9em;">Start a live feed to begin capturing events</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- END HISTORY TAB -->
    </div>

    <!-- Stage Details Modal -->
    <div class="stage-modal" id="stageModal">
        <div class="stage-modal-content">
            <div class="stage-modal-header">
                <div class="stage-modal-title" id="stageModalTitle">STAGE DETAILS</div>
                <button class="stage-modal-close" onclick="closeStageModal()">✕ CLOSE</button>
            </div>
            <div class="stage-modal-body" id="stageModalBody">
                <!-- Content will be populated dynamically -->
            </div>
        </div>
    </div>

    <!-- Live Feed Modal (Moved outside all tabs) -->
    <div id="liveFeedModal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h3 style="margin: 0; font-size: 1.1em; font-weight: 600; letter-spacing: 1px;">LIVE CAMERA / STREAM FEED</h3>
                <button class="close-btn" onclick="closeLiveFeedModal()">×</button>
            </div>
            <div class="modal-body" style="padding: 20px;">
                <!-- Compact 2-column form layout -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                    <!-- Feed Type Selection -->
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-size: 0.75em; color: var(--gray-light); text-transform: uppercase; letter-spacing: 0.5px;">Feed Type</label>
                        <select id="liveFeedType" class="form-input" onchange="toggleLiveFeedOptions()" style="padding: 8px;">
                            <option value="webcam">Webcam / Local Camera</option>
                            <option value="rtsp">RTSP Stream</option>
                            <option value="rtmp">RTMP Stream</option>
                            <option value="http">HTTP Live Stream (HLS/DASH)</option>
                        </select>
                    </div>
                    
                    <!-- Camera Device -->
                    <div id="webcamOptions">
                        <label style="display: block; margin-bottom: 5px; font-size: 0.75em; color: var(--gray-light); text-transform: uppercase; letter-spacing: 0.5px;">Camera Device</label>
                        <select id="cameraDevice" class="form-input" style="padding: 8px;">
                            <option value="user">Front Camera</option>
                            <option value="environment">Back Camera (Mobile)</option>
                        </select>
                    </div>
                    
                    <!-- Processing Mode -->
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-size: 0.75em; color: var(--gray-light); text-transform: uppercase; letter-spacing: 0.5px;">Processing Mode</label>
                        <select id="liveProcessingMode" class="form-input" onchange="toggleIntervalOptions()" style="padding: 8px;">
                            <option value="continuous">Continuous (Real-time)</option>
                            <option value="interval">Interval (Every N seconds)</option>
                            <option value="motion">Motion Triggered</option>
                        </select>
                    </div>
                    
                    <!-- Analysis Interval -->
                    <div id="intervalOptions" style="display: none;">
                        <label style="display: block; margin-bottom: 5px; font-size: 0.75em; color: var(--gray-light); text-transform: uppercase; letter-spacing: 0.5px;">Interval (sec)</label>
                        <input type="number" id="analysisInterval" class="form-input" value="5" min="1" max="60" style="padding: 8px;">
                    </div>
                </div>
                
                <!-- Stream URL Options (full width when visible) -->
                <div id="streamUrlOptions" style="display: none; margin-top: 12px;">
                    <label style="display: block; margin-bottom: 5px; font-size: 0.75em; color: var(--gray-light); text-transform: uppercase; letter-spacing: 0.5px;">Stream URL</label>
                    <input type="text" id="streamUrl" class="form-input" placeholder="rtsp://camera.example.com:554/stream" style="padding: 8px; font-size: 0.85em;">
                </div>
                
                <!-- Auto-save Events Option (Compact) -->
                <div style="margin-top: 12px; padding: 10px; background: var(--gray-dark); border-radius: 4px;">
                    <label style="display: flex; align-items: center; cursor: pointer; margin: 0;">
                        <input type="checkbox" id="autoSaveEvents" checked style="margin-right: 8px; width: 14px; height: 14px;">
                        <span style="font-size: 0.85em;">Auto-save events to Live Events tab</span>
                    </label>
                </div>
                
                <!-- Live Preview Area (Compact) -->
                <div id="livePreviewArea" style="display: none; margin-top: 12px;">
                    <label style="display: block; margin-bottom: 6px; font-weight: 500; font-size: 0.85em;">Live Preview</label>
                    <div style="position: relative; background: #000; border: 1px solid var(--gray-medium); border-radius: 6px; overflow: hidden; max-height: 250px;">
                        <video id="livePreviewVideo" autoplay muted style="width: 100%; height: auto; display: block; max-height: 250px; object-fit: contain;"></video>
                        <canvas id="liveDetectionCanvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></canvas>
                    </div>
                    <div id="liveAnalysisStatus" style="margin-top: 8px; padding: 6px 10px; background: var(--gray-dark); border-radius: 4px; font-size: 0.75em; display: none;">
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; text-align: center;">
                            <div>
                                <div style="font-size: 0.7em; color: var(--gray-light); margin-bottom: 2px;">STATUS</div>
                                <strong id="liveStatusText" style="font-size: 0.9em;">Idle</strong>
                            </div>
                            <div>
                                <div style="font-size: 0.7em; color: var(--gray-light); margin-bottom: 2px;">FRAMES</div>
                                <strong id="framesAnalyzed" style="font-size: 0.9em;">0</strong>
                            </div>
                            <div>
                                <div style="font-size: 0.7em; color: var(--gray-light); margin-bottom: 2px;">VIOLENCE</div>
                                <strong id="liveViolenceScore" style="font-size: 0.9em;">0%</strong>
                            </div>
                            <div>
                                <div style="font-size: 0.7em; color: var(--gray-light); margin-bottom: 2px;">OBJECTS</div>
                                <strong id="liveObjectCount" style="font-size: 0.9em;">0</strong>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Action Buttons -->
                <div style="display: flex; gap: 8px; justify-content: flex-end; margin-top: 15px;">
                    <button class="btn" onclick="closeLiveFeedModal()" style="background: var(--gray-medium); padding: 8px 16px; font-size: 0.9em;">CANCEL</button>
                    <button class="btn" id="startLiveFeedBtn" onclick="startLiveFeed()" style="padding: 8px 16px; font-size: 0.9em;">START LIVE FEED</button>
                    <button class="btn" id="stopLiveFeedBtn" onclick="stopLiveFeed()" style="display: none; background: #ff0000; padding: 8px 16px; font-size: 0.9em;">STOP FEED</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Live Event Viewer Modal (Moved outside all tabs) -->
    <div id="liveEventViewerModal" class="modal" style="display: none; z-index: 10000; position: fixed;">
        <div class="modal-content" style="max-width: 900px; position: relative; z-index: 10001;">
            <div class="modal-header">
                <h3 style="margin: 0; font-size: 1.1em; font-weight: 600; letter-spacing: 1px;">LIVE EVENT DETAILS</h3>
                <button class="close-btn" onclick="closeLiveEventViewer()">×</button>
            </div>
            <div class="modal-body" style="padding: 30px;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px;">
                    <!-- Left: Frame Image -->
                    <div>
                        <label style="display: block; margin-bottom: 10px; font-weight: 500;">Captured Frame</label>
                        <div style="position: relative; background: #000; border: 1px solid var(--gray-medium); border-radius: 8px; overflow: hidden;">
                            <img id="eventFrameImage" style="width: 100%; height: auto; display: block;">
                            <canvas id="eventDetectionCanvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></canvas>
                        </div>
                    </div>
                    
                    <!-- Right: Event Details -->
                    <div>
                        <div id="eventDetails"></div>
                        
                        <!-- Manual Review Section -->
                        <div style="margin-top: 20px; padding: 15px; background: var(--gray-dark); border-radius: 8px;">
                            <label style="display: block; margin-bottom: 10px; font-weight: 500;">Manual Review</label>
                            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                                <button class="btn" onclick="markEventAs('safe')" style="flex: 1; background: #00aa00;">SAFE</button>
                                <button class="btn" onclick="markEventAs('violation')" style="flex: 1; background: #ff0000;">VIOLATION</button>
                            </div>
                            <textarea id="eventNotes" placeholder="Add notes..." style="width: 100%; padding: 10px; background: var(--black); border: 1px solid var(--gray-medium); color: var(--white); border-radius: 4px; min-height: 80px; font-family: inherit;"></textarea>
                            <button class="btn" onclick="saveEventReview()" style="margin-top: 10px; width: 100%;">SAVE REVIEW</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_URL = 'http://localhost:8012/v1';
        const WS_URL = 'ws://localhost:8012/v1';
        
        // Batch processing state
        let videoQueue = [];
        let currentBatchId = null;
        let batchWebSocket = null;
        let processingBatch = false;
        let currentViewingVideo = null; // Track which video we're currently viewing in pipeline panel
        let videoWebSockets = {}; // Map of video_id -> WebSocket for independent tracking
        let tableListenersAttached = false; // Event delegation flag for table
        
        // Legacy single video state (for backward compatibility)
        let selectedFile = null;
        let websocket = null;
        let stageStartTimes = {};
        let analysisHistory = [];
        let sessionStats = {
            videosAnalyzed: 0,
            violationsFound: 0
        };
        let currentResults = null;
        let currentAnalysisData = null;

        // DOM Elements - Batch
        const addVideosBtn = document.getElementById('addVideosBtn');
        const batchFileInput = document.getElementById('batchFileInput');
        const processAllBtn = document.getElementById('processAllBtn');
        const clearCompletedBtn = document.getElementById('clearCompletedBtn');
        const emptyState = document.getElementById('emptyState');
        const videosTableContainer = document.getElementById('videosTableContainer');
        const videosTableBody = document.getElementById('videosTableBody');
        const batchSummary = document.getElementById('batchSummary');
        const loadingState = document.getElementById('loadingState');
        const errorDisplay = document.getElementById('errorDisplay');

        // Tab Navigation
        document.querySelectorAll('.sidebar-link').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const tabName = link.getAttribute('data-tab');
                
                // Update active link
                document.querySelectorAll('.sidebar-link').forEach(l => l.classList.remove('active'));
                link.classList.add('active');
                
                // Show corresponding tab content
                document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
                document.getElementById(tabName).classList.add('active');
                
                // Clean up live feed when switching away from it
                if (tabName !== 'live-events' && liveStream) {
                    // Clear the canvas when leaving live events tab
                    const liveCanvas = document.getElementById('liveDetectionCanvas');
                    if (liveCanvas) {
                        const ctx = liveCanvas.getContext('2d');
                        if (ctx) {
                            ctx.clearRect(0, 0, liveCanvas.width, liveCanvas.height);
                        }
                    }
                    // Stop live feed preview when switching tabs
                    const liveVideo = document.getElementById('livePreviewVideo');
                    if (liveVideo && liveVideo.srcObject) {
                        // Don't stop the stream, just pause it temporarily
                        // It will resume when user comes back to live feed
                    }
                }
                
                // Update tab-specific content
                if (tabName === 'analytics') {
                    updateAnalyticsTab();
                } else if (tabName === 'history') {
                    updateHistoryTab();
                }
            });
        });

        // ===== UTILITY FUNCTIONS =====
        
        // Check API status on load
        async function checkAPIStatus() {
            const statusEl = document.getElementById('apiHealthStatus');
            try {
                const response = await fetch(`${API_URL}/health`);
                if (response.ok) {
                    if (statusEl) statusEl.textContent = 'ONLINE';
                    if (statusEl) statusEl.style.color = 'var(--white)';
                } else {
                    if (statusEl) statusEl.textContent = 'ERROR';
                    if (statusEl) statusEl.style.color = '#ff0000';
                    console.warn('API health check failed');
                }
            } catch (error) {
                if (statusEl) statusEl.textContent = 'OFFLINE';
                if (statusEl) statusEl.style.color = '#ff0000';
                console.error('Cannot connect to API:', error);
            }
        }

        // Check API status on load
        checkAPIStatus();
        
        // Load saved results on page load
        loadResultsFromPersistence();
        
        // Check for checkpoints and restore interrupted videos
        checkAndRestoreCheckpoints();

        // ===== BATCH PROCESSING FUNCTIONS =====
        
        // Batch upload interactions
        addVideosBtn.addEventListener('click', () => {
            // Show data source selection modal
            document.getElementById('dataSourceModal').style.display = 'flex';
        });
        
        // Also support drag and drop on the entire panel
        const batchPanel = document.getElementById('batchPanel');
        batchPanel.addEventListener('dragover', (e) => {
            e.preventDefault();
            addVideosBtn.style.background = 'var(--white)';
            addVideosBtn.style.color = 'var(--black)';
        });
        
        batchPanel.addEventListener('dragleave', () => {
            addVideosBtn.style.background = 'transparent';
            addVideosBtn.style.color = 'var(--white)';
        });
        
        batchPanel.addEventListener('drop', (e) => {
            e.preventDefault();
            addVideosBtn.style.background = 'transparent';
            addVideosBtn.style.color = 'var(--white)';
            const files = e.dataTransfer.files;
            handleBatchFileSelect(files);
        });
        
        batchFileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleBatchFileSelect(e.target.files);
            }
        });
        
        processAllBtn.addEventListener('click', processAllVideos);
        clearCompletedBtn.addEventListener('click', clearCompletedVideos);
        
        function generateId() {
            return 'vid_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }
        
        function handleBatchFileSelect(files) {
            for (let file of files) {
                if (file.type.startsWith('video/') || file.name.endsWith('.zip')) {
                    addVideoToQueue(file, file.name, generateId(), 'local');
                }
            }
        }
        
        function attachTableEventListeners() {
            // Only attach once
            if (tableListenersAttached) return;
            
            // Check if videosTableBody exists (old table system)
            if (!videosTableBody) {
                console.log('Table system not in use, skipping table event listeners');
                tableListenersAttached = true;
                return;
            }
            
            tableListenersAttached = true;
            
            // Use event delegation for all clicks
            videosTableBody.addEventListener('click', (e) => {
                const target = e.target;
                
                // Handle filename cell click
                const filenameCell = target.closest('.filename-cell');
                if (filenameCell) {
                    const videoId = filenameCell.getAttribute('data-video-id');
                    if (videoId) {
                        console.log('Filename clicked, opening preview for:', videoId);
                        openVideoPreview(videoId);
                    }
                    return;
                }
                
                // Handle button clicks
                const button = target.closest('button');
                if (button) {
                    const videoId = button.getAttribute('data-video-id');
                    if (!videoId) return;
                    
                    e.stopPropagation();
                    
                    if (button.classList.contains('process-btn')) {
                        processSingleVideo(videoId);
                    } else if (button.classList.contains('watch-btn')) {
                        // Open pipeline view for in-progress video
                        viewVideoReport(videoId);
                    } else if (button.classList.contains('retry-btn')) {
                        retryVideo(videoId);
                    } else if (button.classList.contains('pipeline-btn')) {
                        viewVideoReport(videoId);
                    } else if (button.classList.contains('remove-btn')) {
                        removeVideo(videoId);
                    }
                }
            });
        }
        
        // ===== FILE TREE VIEW FUNCTIONS =====
        
        function renderFileTreeView() {
            const splitPane = document.getElementById('splitPaneContainer');
            const emptyState = document.getElementById('emptyState');
            const fileTreeContent = document.getElementById('fileTreeContent');
            const fileTreeCount = document.getElementById('fileTreeCount');
            
            if (videoQueue.length === 0) {
                splitPane.style.display = 'none';
                emptyState.style.display = 'block';
                currentViewingVideo = null;
                return;
            }
            
            emptyState.style.display = 'none';
            splitPane.style.display = 'flex';
            
            // Update count
            fileTreeCount.textContent = `${videoQueue.length} video${videoQueue.length !== 1 ? 's' : ''}`;
            
            // If no video is currently selected, select the last one
            if (!currentViewingVideo || !videoQueue.find(v => v.id === currentViewingVideo)) {
                // Default to the most recently processed/completed video, or the last in queue
                const lastCompleted = [...videoQueue].reverse().find(v => v.status === 'completed');
                const lastProcessing = videoQueue.find(v => v.status === 'processing');
                const defaultVideo = lastProcessing || lastCompleted || videoQueue[videoQueue.length - 1];
                
                if (defaultVideo) {
                    currentViewingVideo = defaultVideo.id;
                    console.log(`📌 Default selected video: ${defaultVideo.filename}`);
                    // Show pipeline for default video (but don't call selectFileTreeVideo to avoid loop)
                    setTimeout(() => showVideoPipelineInPane(defaultVideo), 0);
                }
            }
            
            // Render file tree items
            fileTreeContent.innerHTML = videoQueue.map(video => {
                const sourceIcons = {
                    'local': `<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M8 0L6.5 1.5 10 5H0v2h10l-3.5 3.5L8 12l6-6z"/></svg>`,
                    'storage': `<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M4.5 3A3.5 3.5 0 0 0 1 6.5c0 1.6 1.1 2.9 2.5 3.3v.7c0 .8.7 1.5 1.5 1.5h6c.8 0 1.5-.7 1.5-1.5v-.7c1.4-.4 2.5-1.7 2.5-3.3A3.5 3.5 0 0 0 11.5 3H4.5z"/></svg>`,
                    'database': `<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M8 1c3 0 5 .5 5 1.5v11c0 1-2 1.5-5 1.5s-5-.5-5-1.5v-11C3 1.5 5 1 8 1zm0 2c-2 0-3-.3-3-.5S6 2 8 2s3 .3 3 .5S10 3 8 3z"/></svg>`,
                    'url': `<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M7 4l-1.5 1.5L8 8 5.5 10.5 7 12l4-4-4-4z"/></svg>`
                };
                const sourceIcon = sourceIcons[video.source || 'local'] || sourceIcons['local'];
                
                const statusClass = video.status === 'processing' ? 'processing' :
                                  video.status === 'completed' ? 'completed' :
                                  video.status === 'failed' ? 'failed' : 'pending';
                
                const statusText = video.status === 'processing' ? 'In Progress' :
                                 video.status === 'completed' ? 'Complete' :
                                 video.status === 'failed' ? 'Failed' : 'Queued';
                
                const verdictBadge = video.verdict ? 
                    `<span style="font-size: 0.65em; padding: 2px 6px; border-radius: 3px; background: ${
                        video.verdict === 'UNSAFE' ? 'rgba(255,0,0,0.2)' :
                        video.verdict === 'SAFE' ? 'rgba(0,170,0,0.2)' :
                        'rgba(255,170,0,0.2)'
                    }; color: ${
                        video.verdict === 'UNSAFE' ? '#ff0000' :
                        video.verdict === 'SAFE' ? '#00aa00' :
                        '#ffaa00'
                    };">${video.verdict}</span>` : '';
                
                return `
                    <div class="file-tree-item ${currentViewingVideo === video.id ? 'active' : ''}" 
                         data-video-id="${video.id}">
                        <div style="flex: 1; display: flex; align-items: center; gap: 12px; min-width: 0;" onclick="selectFileTreeVideo('${video.id}')">
                            <div class="file-tree-details" style="flex: 1; min-width: 0;">
                                <div class="file-tree-name" title="${video.filename}">${video.filename}</div>
                                <div class="file-tree-meta">
                                    <div class="file-tree-status">
                                        <span class="file-tree-status-indicator ${statusClass}"></span>
                                        <span>${statusText}</span>
                                    </div>
                                    ${verdictBadge}
                                    ${video.duration ? `<span>${video.duration}</span>` : ''}
                                </div>
                            </div>
                        </div>
                        <div class="file-tree-actions" style="display: flex; gap: 4px; flex-shrink: 0; opacity: 0; transition: opacity 0.2s;">
                            ${video.status === 'queued' ? `
                                <button class="icon-btn" onclick="event.stopPropagation(); processSingleVideo('${video.id}');" title="Process This Video" style="font-size: 0.9em; padding: 4px; color: #00aa00;">
                                    <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor">
                                        <path d="M3 2l10 6-10 6V2z"/>
                                    </svg>
                                </button>
                            ` : ''}
                            ${video.status === 'failed' ? `
                                <button class="icon-btn" onclick="event.stopPropagation(); retryVideo('${video.id}');" title="Retry Processing" style="font-size: 0.9em; padding: 4px; color: #ffaa00;">
                                    <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor">
                                        <path d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/>
                                        <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/>
                                    </svg>
                                </button>
                            ` : ''}
                            ${video.result ? `
                                <button class="icon-btn" onclick="event.stopPropagation(); openVideoPreview('${video.id}');" title="Preview Original" style="font-size: 0.9em; padding: 4px;">
                                    <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor">
                                        <path d="M8 3.5a4.5 4.5 0 1 0 0 9 4.5 4.5 0 0 0 0-9zM1.17 8a6.83 6.83 0 1 1 13.66 0 6.83 6.83 0 0 1-13.66 0z"/>
                                        <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
                                    </svg>
                                </button>
                            ` : ''}
                            ${video.status !== 'processing' ? `
                                <button class="icon-btn" onclick="event.stopPropagation(); removeVideo('${video.id}');" title="Remove" style="font-size: 1em; padding: 4px;">×</button>
                            ` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function selectFileTreeVideo(videoId) {
            const video = videoQueue.find(v => v.id === videoId);
            if (!video) return;
            
            // Update current viewing video
            currentViewingVideo = videoId;
            
            // Update active state in file tree
            document.querySelectorAll('.file-tree-item').forEach(item => {
                if (item.getAttribute('data-video-id') === videoId) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
            
            // Show pipeline in right pane
            showVideoPipelineInPane(video);
        }
        
        function showVideoPipelineInPane(video) {
            const pipelineEmptyState = document.getElementById('pipelineEmptyState');
            const pipelineDetailContent = document.getElementById('pipelineDetailContent');
            
            pipelineEmptyState.style.display = 'none';
            pipelineDetailContent.style.display = 'block';
            
            // For all statuses, use the compact pipeline view
            if (video.status === 'queued') {
                // Show queued state with compact header
                pipelineDetailContent.innerHTML = `
                    <div style="padding: 10px 15px; background: var(--black); border-bottom: 1px solid var(--gray-medium);">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor" style="flex-shrink: 0; opacity: 0.7;">
                                <path d="M0 1.5A1.5 1.5 0 0 1 1.5 0h13A1.5 1.5 0 0 1 16 1.5v10a1.5 1.5 0 0 1-1.5 1.5h-13A1.5 1.5 0 0 1 0 11.5v-10z"/>
                            </svg>
                            <div style="font-size: 0.8em; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="${video.filename}">${video.filename}</div>
                            <span style="color: var(--gray-light); font-size: 0.7em; margin-left: 6px;">(QUEUED)</span>
                        </div>
                    </div>
                    <div style="display: flex; align-items: center; justify-content: center; height: calc(100% - 50px); text-align: center; padding: 40px 20px; color: var(--gray-light);">
                        <div>
                            <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="opacity: 0.3; margin-bottom: 15px;">
                                <circle cx="12" cy="12" r="10"/>
                                <path d="M12 6v6l4 2"/>
                            </svg>
                            <div style="font-size: 0.9em; margin-bottom: 8px;">This video is queued for processing</div>
                            <div style="font-size: 0.75em; color: var(--primary);">Click the play icon (▶) in the file tree to start</div>
                        </div>
                    </div>
                `;
            } else if (video.status === 'failed') {
                // Show failed state with compact header
                pipelineDetailContent.innerHTML = `
                    <div style="padding: 10px 15px; background: var(--black); border-bottom: 1px solid var(--gray-medium);">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <svg width="14" height="14" viewBox="0 0 16 16" fill="#ff0000" style="flex-shrink: 0;">
                                <path d="M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0zM7 4h2v5H7V4zm0 6h2v2H7v-2z"/>
                            </svg>
                            <div style="font-size: 0.8em; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="${video.filename}">${video.filename}</div>
                            <span style="color: #ff0000; font-size: 0.7em; margin-left: 6px;">(FAILED)</span>
                        </div>
                    </div>
                    <div style="display: flex; align-items: center; justify-content: center; height: calc(100% - 50px); text-align: center; padding: 40px 20px;">
                        <div>
                            <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#ff0000" stroke-width="1.5" style="opacity: 0.5; margin-bottom: 15px;">
                                <circle cx="12" cy="12" r="10"/>
                                <line x1="15" y1="9" x2="9" y2="15"/>
                                <line x1="9" y1="9" x2="15" y2="15"/>
                            </svg>
                            <div style="font-size: 0.9em; margin-bottom: 8px; color: #ff0000;">Processing failed</div>
                            ${video.error ? `<div style="font-size: 0.8em; color: var(--gray-light); max-width: 400px; margin: 0 auto 15px;">${video.error}</div>` : ''}
                            ${hasCheckpoint(video) ? 
                                `<div style="font-size: 0.75em; color: var(--primary); margin-bottom: 10px;">
                                    <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor" style="vertical-align: middle; margin-right: 5px;">
                                        <path d="M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0zM7 4h2v5H7V4zm0 6h2v2H7v-2z"/>
                                    </svg>
                                    Checkpoint available - can resume
                                </div>` : ''}
                            <div style="font-size: 0.75em; color: var(--gray-light);">Click the retry icon (↻) in the file tree to ${hasCheckpoint(video) ? 'resume' : 'retry'}</div>
                        </div>
                    </div>
                `;
            } else if (video.status === 'processing' || video.status === 'completed') {
                // Show live pipeline progress or completed results
                renderVideoInRightPane(video);
            }
        }
        
        function renderVideoTable() {
            // Handle empty queue
            if (videoQueue.length === 0) {
                if (emptyState) emptyState.style.display = 'block';
                if (videosTableContainer) videosTableContainer.style.display = 'none';
                const splitPane = document.getElementById('splitPaneContainer');
                if (splitPane) splitPane.style.display = 'none';
                if (processAllBtn) processAllBtn.disabled = true;
                return;
            }
            
            // Hide empty state
            if (emptyState) emptyState.style.display = 'none';
            
            // Show split pane (new layout) and hide old table
            const splitPane = document.getElementById('splitPaneContainer');
            if (splitPane) {
                splitPane.style.display = 'flex';
                if (videosTableContainer) videosTableContainer.style.display = 'none';
            } else {
                // Fallback to old table layout if split pane doesn't exist
                if (videosTableContainer) videosTableContainer.style.display = 'block';
            }
            
            if (processAllBtn) processAllBtn.disabled = processingBatch;
            
            // Render old table (for backward compatibility, even though it's hidden)
            if (videosTableBody) {
                videosTableBody.innerHTML = videoQueue.map(video => {
                    // Get source icon
                    const sourceIcons = {
                        'local': '⬆',
                        'storage': '☁',
                        'database': '▦',
                        'url': '⎘'
                    };
                    const sourceIcon = sourceIcons[video.source || 'local'] || '⬆';
                    const sourceTitle = (video.source || 'local').toUpperCase();
                    
                    return `
                    <tr data-id="${video.id}">
                        <td class="filename-cell" data-video-id="${video.id}" style="font-weight: 500; cursor: pointer; position: relative;" title="Click to preview video">
                            <span style="border-bottom: 1px dotted var(--gray-light); padding-bottom: 2px;">
                                <span style="opacity: 0.6; margin-right: 6px;" title="Source: ${sourceTitle}">${sourceIcon}</span>${video.filename}
                            </span>
                        </td>
                        <td>
                            <span class="video-status ${video.status}">${video.status}</span>
                        </td>
                        <td>
                            ${video.verdict ? `<span class="verdict-badge verdict-${video.verdict.toLowerCase()}" style="font-size: 0.7em; padding: 4px 8px;">${video.verdict}</span>` : '—'}
                        </td>
                        <td style="color: var(--gray-light);">${video.duration || '—'}</td>
                        <td class="video-actions">
                            ${video.status === 'queued' ? `
                                <button class="icon-btn process-btn" data-video-id="${video.id}" title="Process This Video" style="color: #00aa00;">▶</button>
                            ` : ''}
                            ${video.status === 'processing' ? `
                                <button class="icon-btn watch-btn" data-video-id="${video.id}" title="Watch Live Progress" style="color: #00aaff; animation: spin 2s linear infinite;">⟳</button>
                            ` : ''}
                            ${video.status === 'failed' ? `
                                <button class="icon-btn retry-btn" data-video-id="${video.id}" title="${hasCheckpoint(video) ? 'Resume from checkpoint' : 'Retry from beginning'}" style="color: #ffaa00;">↻</button>
                            ` : ''}
                            ${video.status === 'completed' ? `
                                <button class="icon-btn pipeline-btn" data-video-id="${video.id}" title="View Pipeline & Results">▤</button>
                            ` : ''}
                            ${video.status !== 'processing' ? `
                                <button class="icon-btn remove-btn" data-video-id="${video.id}" title="Remove">×</button>
                            ` : ''}
                        </td>
                    </tr>
                `;
                }).join('');
            }
            
            // Also render file tree view
            renderFileTreeView();
            
            // Attach event listeners on first render only
            if (!tableListenersAttached) {
                attachTableEventListeners();
            }
            
            updateBatchSummary();
            
            // Show clear button if there are completed videos
            const hasCompleted = videoQueue.some(v => v.status === 'completed' || v.status === 'failed');
            clearCompletedBtn.style.display = hasCompleted ? 'block' : 'none';
        }
        
        function updateBatchSummary() {
            // Batch summary section removed from UI, keeping function for backwards compatibility
            // This function is no longer needed but kept to prevent errors from existing calls
            return;
        }
        
        async function processAllVideos() {
            if (processingBatch) return;
            
            // Filter out already completed or currently processing videos
            const videosToProcess = videoQueue.filter(v => 
                v.status !== 'completed' && 
                v.status !== 'processing' &&
                v.file  // Must have file
            );
            
            if (videosToProcess.length === 0) {
                alert('No videos to process. All videos are either completed or already processing.');
                return;
            }
            
            processingBatch = true;
            processAllBtn.disabled = true;
            processAllBtn.textContent = '⟳ PROCESSING...';
            
            const formData = new FormData();
            videosToProcess.forEach(video => {
                formData.append('files', video.file);
            });
            
            // Add policy config if set
            if (currentPolicy) {
                formData.append('policy', JSON.stringify(currentPolicy));
            }
            
            try {
                const response = await fetch(`${API_URL}/evaluate/batch`, {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error('Batch submission failed');
                }
                
                const data = await response.json();
                currentBatchId = data.batch_id;
                
                // Map batch response to our queue and connect WebSocket for each video
                data.videos.forEach(batchVideo => {
                    const queueVideo = videoQueue.find(v => v.filename === batchVideo.filename);
                    if (queueVideo) {
                        queueVideo.batchVideoId = batchVideo.video_id;
                        queueVideo.status = batchVideo.status;
                        
                        // Connect individual WebSocket for this video
                        connectVideoSSE(batchVideo.video_id, queueVideo);
                    }
                });
                
                renderVideoTable();
                
                // Connect to WebSocket for updates
                connectBatchWebSocket(currentBatchId);
                
                // Start polling for status
                pollBatchStatus(currentBatchId);
                
            } catch (error) {
                console.error('Failed to process batch:', error);
                showError('Failed to start batch processing: ' + error.message);
                processingBatch = false;
                processAllBtn.disabled = false;
                processAllBtn.textContent = '▶ PROCESS ALL';
            }
        }
        
        async function processSingleVideo(videoId) {
            const video = videoQueue.find(v => v.id === videoId);
            if (!video) return;
            
            // Check if already processed
            if (video.status === 'completed') {
                console.warn(`"${video.filename}" has already been processed.`);
                return;
            }
            
            // If already processing, allow it (could be a retry)
            if (video.status === 'processing') {
                console.log(`"${video.filename}" is being processed.`);
            }
            
            if (!video.file) {
                console.error('Cannot process: video file not available.');
                return;
            }
            
            // Set status to processing
            video.status = 'processing';
            video.currentStage = 'ingest_video';  // Set initial stage
            if (video.progress === undefined || video.progress === null) {
                video.progress = 0;
            }
            renderVideoTable();
            
            // Show immediate feedback in UI
            console.log(`🚀 Starting processing for ${video.filename}`);
            
            const formData = new FormData();
            formData.append('files', video.file);
            
            // Add policy config if set
            if (currentPolicy) {
                formData.append('policy', JSON.stringify(currentPolicy));
            }
            
            try {
                const response = await fetch(`${API_URL}/evaluate/batch`, {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error('Video submission failed');
                }
                
                const data = await response.json();
                const batchVideo = data.videos[0];
                
                if (batchVideo) {
                    video.batchVideoId = batchVideo.video_id;
                    video.status = batchVideo.status;
                    
                    // Connect WebSocket for progress updates
                    connectVideoSSE(batchVideo.video_id, video);
                    
                    // Start polling for this batch
                    pollBatchStatus(data.batch_id);
                    
                    renderVideoTable();
                }
                
            } catch (error) {
                console.error('Failed to process video:', error);
                video.status = 'failed';
                video.error = error.message;
                renderVideoTable();
                showError('Failed to process video: ' + error.message);
            }
        }
        
        // Retry a failed video OR resume from checkpoint
        async function retryVideo(videoId) {
            const video = videoQueue.find(v => v.id === videoId);
            if (!video) return;
            
            // Check if there's a checkpoint for this video on the server
            // Try multiple ID formats to find the checkpoint
            let checkpoint = null;
            const idsToTry = [
                videoId,                    // Primary video ID
                video.batchVideoId,         // Batch video ID (if available)
                video.id                    // Fallback to stored ID
            ].filter(Boolean);              // Remove null/undefined values
            
            for (const checkpointId of idsToTry) {
                try {
                    const response = await fetch(`${API_URL}/checkpoints/load/${checkpointId}`);
                    if (response.ok) {
                        const data = await response.json();
                        checkpoint = data.checkpoint || data;  // Handle both wrapped and unwrapped responses
                        console.log(`🔄 Resuming from checkpoint: ${video.filename} at stage ${checkpoint.stage || 'unknown'}`);
                        break;  // Found it, stop looking
                    }
                } catch (error) {
                    // Continue to next ID
                }
            }
            
            if (!checkpoint) {
                console.log(`🔄 Retrying video: ${video.filename} from beginning`);
            }
            
            // If video file not available, try to fetch from backend
            // Try multiple ID formats: batchVideoId, video.id, or videoId
            if (!video.file) {
                const videoIdToFetch = video.batchVideoId || video.id || videoId;
                console.log(`Fetching uploaded video from backend: ${videoIdToFetch}`);
                try {
                    const response = await fetch(`${API_URL}/video/uploaded/${videoIdToFetch}`);
                    if (response.ok) {
                        const blob = await response.blob();
                        video.file = new File([blob], video.filename, { type: 'video/mp4' });
                        console.log(`✅ Retrieved video file from backend`);
                    } else {
                        console.warn(`Could not fetch video from backend: ${response.status}`);
                        console.error(`Cannot retry "${video.filename}": original file not available (${response.status}). Please re-upload.`);
                        return;
                    }
                } catch (error) {
                    console.error('Failed to fetch video:', error);
                    console.error(`Cannot retry "${video.filename}": failed to retrieve file. Please re-upload.`);
                    return;
                }
            }
            
            // Reset video state
            video.status = 'processing';  // Set directly to processing
            video.progress = checkpoint ? checkpoint.progress : 0;
            video.currentStage = checkpoint ? checkpoint.stage : null;
            video.error = null;
            video.result = null;
            
            renderVideoTable();
            updateBatchSummary();
            
            // Process immediately
            await processSingleVideo(videoId);
        }
        
        // ===== CHECKPOINT SYSTEM (Server-side) =====
        
        // Note: Checkpoints are now stored on the server
        // No localStorage functions needed - everything is handled via API
        
        function hasCheckpoint(video) {
            // Check if video has checkpoint info from server
            return video.progress > 0 && video.progress < 100 && video.status === 'failed';
        }
                
        async function resumeFromCheckpoint(checkpoint) {
            console.log(`🔄 Resuming from checkpoint: ${checkpoint.filename}`);
            
            // Find the video in queue
            const video = videoQueue.find(v => v.id === checkpoint.videoId || v.batchVideoId === checkpoint.batchVideoId);
            
            if (!video) {
                console.warn('Video not found in queue for checkpoint:', checkpoint.filename);
                return false;
            }
            
            // Use retry function which handles fetching video if needed
            await retryVideo(video.id);
            return true;
        }
        
        // Check for checkpoints on page load and restore interrupted videos to queue
        async function checkAndRestoreCheckpoints() {
            try {
                // Fetch checkpoints from server
                const response = await fetch(`${API_URL}/checkpoints/list`);
                if (!response.ok) {
                    console.error('Failed to fetch checkpoints');
                    return;
                }
                
                const data = await response.json();
                const checkpoints = data.checkpoints || [];
                
                if (checkpoints.length > 0) {
                    console.log(`Found ${checkpoints.length} checkpoint(s) on server`);
                    
                    // Restore videos to queue
                    checkpoints.forEach(checkpoint => {
                        // Check if video already in queue
                        const exists = videoQueue.find(v => 
                            v.id === checkpoint.video_id || 
                            v.batchVideoId === checkpoint.batch_video_id ||
                            v.filename === checkpoint.filename
                        );
                        
                        if (exists) {
                            // If video is completed, clear its checkpoint
                            if (exists.status === 'completed') {
                                clearServerCheckpoint(checkpoint.video_id);
                            }
                            console.log(`Skipping checkpoint for ${checkpoint.filename} - already in queue`);
                            return;
                        }
                        
                        // Add video to queue with failed status for retry
                        const video = {
                            id: checkpoint.video_id,
                            filename: checkpoint.filename,
                            file: null,  // File not available after reload
                            status: 'failed',
                            progress: checkpoint.progress || 0,
                            currentStage: checkpoint.stage,
                            verdict: null,
                            result: null,
                            batchVideoId: checkpoint.batch_video_id,
                            error: `Processing interrupted at ${checkpoint.progress}% (${checkpoint.stage})`,
                            source: 'local'
                        };
                        
                        videoQueue.push(video);
                        console.log(`Restored: ${checkpoint.filename} (${checkpoint.progress}% complete, stage: ${checkpoint.stage})`);
                    });
                    
                    renderVideoTable();
                }
            } catch (error) {
                console.error('Error checking checkpoints:', error);
            }
        }
        
        async function clearServerCheckpoint(videoId) {
            try {
                await fetch(`${API_URL}/checkpoints/${videoId}`, {
                    method: 'DELETE'
                });
                console.log(`Cleared checkpoint for ${videoId}`);
            } catch (error) {
                console.error(`Failed to clear checkpoint for ${videoId}:`, error);
            }
        }
        
        function connectVideoSSE(videoId, queueVideo) {
            // Close existing EventSource for this video if any
            if (videoWebSockets[videoId]) {
                videoWebSockets[videoId].close();
            }
            
            // Use Server-Sent Events instead of WebSocket
            const eventSource = new EventSource(`${API_URL}/sse/${videoId}`);
            videoWebSockets[videoId] = eventSource;  // Store in same map for compatibility
            
            eventSource.onopen = () => {
                console.log(`✅ SSE connected for video: ${videoId}`);
            };
            
            eventSource.onmessage = (event) => {
                const update = JSON.parse(event.data);
                console.log(`Progress update for ${videoId}:`, update);
                updateVideoProgress(videoId, queueVideo, update);
                
                // Close connection when complete
                if (update.stage === 'complete') {
                    eventSource.close();
                    delete videoWebSockets[videoId];
                }
            };
            
            eventSource.onerror = (error) => {
                console.error(`SSE error for video ${videoId}:`, error);
                eventSource.close();
                delete videoWebSockets[videoId];
            };
        }
        
        function updateVideoProgress(videoId, queueVideo, update) {
            // Checkpoints are now saved automatically on the server via SSE progress updates
            
            // Define pipeline stages with their progress weights
            const stageProgressMap = {
                'ingest_video': 5,        // 5%
                'segment_video': 10,      // 10%
                'yolo26_vision': 25,      // 25%
                'yoloworld_vision': 30,   // 30% NEW
                'violence_detection': 40, // 40%
                'audio_transcription': 55, // 55%
                'ocr_extraction': 65,     // 65%
                'text_moderation': 75,    // 75%
                'policy_fusion': 85,      // 85%
                'report_generation': 95,  // 95%
                'finalize': 100           // 100%
            };
            
            // Update queue video state
            if (update.stage) {
                queueVideo.currentStage = update.stage;
                
                // Backend sends progress as 0-100, normalize to 0-1 if needed
                let normalizedProgress = update.progress;
                if (normalizedProgress > 1) {
                    normalizedProgress = normalizedProgress / 100;
                }
                
                // Calculate accurate progress based on stage
                const currentStageProgress = stageProgressMap[update.stage] || 0;
                const stages = Object.keys(stageProgressMap);
                const currentIndex = stages.indexOf(update.stage);
                
                if (currentIndex >= 0) {
                    const nextStageProgress = currentIndex < stages.length - 1 
                        ? stageProgressMap[stages[currentIndex + 1]] 
                        : 100;
                    
                    // Interpolate: current stage base + (stage progress * stage range)
                    const stageRange = nextStageProgress - currentStageProgress;
                    queueVideo.progress = Math.round(currentStageProgress + (normalizedProgress * stageRange));
                } else {
                    // Unknown stage, just use the base progress
                    queueVideo.progress = currentStageProgress;
                }
                
                // Cap at 100%
                queueVideo.progress = Math.min(queueVideo.progress, 100);
                
                // If pipeline is complete (finalize stage at 100%), mark as completed
                if (update.stage === 'finalize' && queueVideo.progress >= 100) {
                    queueVideo.status = 'completed';
                    console.log(`✅ Video ${queueVideo.filename} completed processing!`);
                }
                
                console.log(`Video ${queueVideo.filename}: Stage ${update.stage}, Progress ${queueVideo.progress}%`);
            } else if (update.progress !== undefined) {
                // If no stage but progress given, use it directly
                queueVideo.progress = Math.round(update.progress > 1 ? update.progress : update.progress * 100);
            }
            
            if (update.message) {
                queueVideo.statusMessage = update.message;
            }
            
            // Update UI - use file tree if available
            const splitPane = document.getElementById('splitPaneContainer');
            if (splitPane && splitPane.style.display === 'flex') {
                renderFileTreeView();
            } else {
                renderVideoTable();
            }
            
            // If this is the currently viewing video in the right pane, update pipeline stages
            // videoId might have a batch suffix (e.g., "video_12345abc"), so check both
            const baseVideoId = queueVideo.id;
            if (currentViewingVideo === baseVideoId || currentViewingVideo === videoId) {
                console.log(`✅ Updating pipeline stages for viewing video: ${queueVideo.filename}`);
                
                // If video is completed, show final results
                if (queueVideo.status === 'completed' && queueVideo.result) {
                    markAllStagesCompleteInRightPane();
                    showResultsInRightPane(queueVideo.result);
                } else {
                    // Update the pipeline stages in the right pane
                    updatePipelineStagesInRightPane(queueVideo);
                }
            } else {
                console.log(`ℹ️ Video ${queueVideo.filename} is updating but not currently viewing (current: ${currentViewingVideo})`);
            }
        }
        
        function updatePipelineStagesLive(update) {
            const stages = document.querySelectorAll('.pipeline-stage');
            const stageMap = {
                'ingest_video': 0,
                'segment_video': 1,
                'yolo26_vision': 2,
                'yoloworld_vision': 3,  // NEW
                'violence_detection': 4,  // CHANGED
                'audio_transcription': 5,  // CHANGED
                'ocr_extraction': 6,      // CHANGED
                'text_moderation': 7,     // CHANGED
                'policy_fusion': 8,       // CHANGED
                'report_generation': 8,
                'finalize': 9
            };
            
            const currentStageIndex = stageMap[update.stage];
            if (currentStageIndex === undefined) return;
            
            // Mark all previous stages as completed
            stages.forEach((stage, index) => {
                const stageIcon = stage.querySelector('.stage-status');
                if (index < currentStageIndex) {
                    stage.classList.add('completed');
                    stage.classList.remove('active', 'pending');
                    if (stageIcon) {
                        stageIcon.textContent = '✓';
                        stageIcon.style.color = '#00aa00';
                    }
                } else if (index === currentStageIndex) {
                    stage.classList.add('active');
                    stage.classList.remove('completed', 'pending');
                    if (stageIcon) {
                        stageIcon.textContent = '⟳';
                        stageIcon.style.color = '#00aaff';
                    }
                } else {
                    stage.classList.add('pending');
                    stage.classList.remove('completed', 'active');
                    if (stageIcon) {
                        stageIcon.textContent = '○';
                        stageIcon.style.color = '';
                    }
                }
            });
            
            // Update the stage output content with live progress
            const stageOutputContent = document.getElementById('stageOutputContent');
            if (stageOutputContent && currentViewingVideo) {
                const progressPercent = currentViewingVideo.progress || 0;
                stageOutputContent.innerHTML = `
                    <div style="padding: 20px; text-align: center;">
                        <div style="font-size: 2em; margin-bottom: 20px; animation: spin 2s linear infinite;">⟳</div>
                        <div style="font-size: 1.2em; margin-bottom: 10px;">Processing In Progress</div>
                        <div style="color: var(--gray-light); margin-bottom: 20px;">
                            Stage: <strong>${formatStageName(update.stage || 'unknown')}</strong><br>
                            Progress: <strong>${progressPercent}%</strong>
                        </div>
                        ${update.message ? `
                            <div style="padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px; margin-top: 20px; text-align: left; font-family: 'Courier New', monospace; font-size: 0.9em;">
                                ${update.message}
                            </div>
                        ` : `
                            <div style="padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px; margin-top: 20px; text-align: left; font-family: 'Courier New', monospace; font-size: 0.9em;">
                                Watch this space for real-time updates as the video progresses through each pipeline stage.
                            </div>
                        `}
                    </div>
                `;
            }
            
            // Update progress bar
            const progressFill = document.getElementById('progressFill');
            if (progressFill && update.progress !== undefined) {
                progressFill.style.width = `${(update.progress * 100)}%`;
            }
        }
        
        function connectBatchWebSocket(batchId) {
            // Deprecated - using individual video WebSockets now
            // Kept for backward compatibility but not used
        }
        
        async function pollBatchStatus(batchId) {
            const pollInterval = setInterval(async () => {
                try {
                    const response = await fetch(`${API_URL}/evaluate/batch/${batchId}`);
                    
                    if (response.status === 404) {
                        // Batch not found (likely server restarted or batch expired)
                        console.warn(`Batch ${batchId} not found. Stopping polling.`);
                        clearInterval(pollInterval);
                        processingBatch = false;
                        processAllBtn.textContent = '▶ PROCESS ALL';
                        
                        // Mark all processing videos as failed
                        videoQueue.forEach(v => {
                            if (v.status === 'processing' || v.status === 'queued') {
                                v.status = 'failed';
                                v.error = 'Batch not found on server (may have restarted)';
                            }
                        });
                        renderVideoTable();
                        return;
                    }
                    
                    if (response.ok) {
                        const data = await response.json();
                        updateVideoStatuses(data);
                        
                        if (data.status === 'completed') {
                            clearInterval(pollInterval);
                            processingBatch = false;
                            processAllBtn.textContent = '▶ PROCESS ALL';
                            if (videoQueue.every(v => v.status === 'completed' || v.status === 'failed')) {
                                processAllBtn.disabled = true;
                            }
                        }
                    } else {
                        console.error(`Polling error: HTTP ${response.status}`);
                    }
                } catch (error) {
                    console.error('Polling error:', error);
                }
            }, 2000);
        }
        
        function updateVideoStatuses(batchData) {
            if (batchData.videos) {
                Object.values(batchData.videos).forEach(batchVideo => {
                    const queueVideo = videoQueue.find(v => v.batchVideoId === batchVideo.video_id || v.filename === batchVideo.filename);
                    if (queueVideo) {
                        const previousStatus = queueVideo.status;
                        queueVideo.status = batchVideo.status;
                        queueVideo.progress = batchVideo.progress || 0;
                        queueVideo.verdict = batchVideo.verdict;
                        queueVideo.error = batchVideo.error;
                        queueVideo.result = batchVideo.result;
                        
                        if (batchVideo.result && batchVideo.result.metadata) {
                            queueVideo.duration = batchVideo.result.metadata.duration ?  batchVideo.result.metadata.duration.toFixed(1) + 's' : null;
                        }
                        
                        // If this video just completed and is currently being viewed, update UI
                        if (previousStatus !== 'completed' && queueVideo.status === 'completed' && currentViewingVideo === queueVideo.id) {
                            console.log(`✅ Currently viewing video ${queueVideo.filename} just completed, updating pipeline view`);
                            markAllStagesCompleteInRightPane();
                            if (queueVideo.result) {
                                showResultsInRightPane(queueVideo.result);
                            }
                            // Keep the video selected
                            renderFileTreeView();
                        }
                    }
                });
            }
            
            // Update UI - use file tree if available
            const splitPane = document.getElementById('splitPaneContainer');
            if (splitPane && splitPane.style.display === 'flex') {
                renderFileTreeView();
            } else {
                renderVideoTable();
            }
            
            // Auto-save when batch completes
            if (batchData.status === 'completed') {
                console.log('Batch completed, auto-saving results...');
                saveResultsToPersistence();
                
                // Clear checkpoints for completed videos
                videoQueue.forEach(v => {
                    if (v.status === 'completed') {
                        clearServerCheckpoint(v.id);
                    }
                });
            }
        }
        
        // ===== PERSISTENCE FUNCTIONS =====
        
        async function saveResultsToPersistence() {
            try {
                // Only save completed videos with results
                const completedVideos = videoQueue.filter(v => v.status === 'completed' && v.result);
                
                if (completedVideos.length === 0) {
                    console.log('No completed videos to save');
                    return;
                }
                
                // Prepare data for saving (exclude file blob but include batchVideoId for file retrieval)
                const resultsToSave = completedVideos.map(v => ({
                    id: v.id,
                    filename: v.filename,
                    status: v.status,
                    verdict: v.verdict,
                    duration: v.duration,
                    result: v.result,
                    batchVideoId: v.batchVideoId, // Save this so we can retrieve the original video
                    timestamp: new Date().toISOString()
                }));
                
                const response = await fetch(`${API_URL}/results/save`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(resultsToSave)
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log(`Saved ${data.count} results to persistent storage`);
                } else {
                    console.error('Failed to save results:', await response.text());
                }
            } catch (error) {
                console.error('Error saving results:', error);
            }
        }
        
        async function loadResultsFromPersistence() {
            try {
                const response = await fetch(`${API_URL}/results/load`);
                
                if (response.ok) {
                    const data = await response.json();
                    
                    if (data.results && data.results.length > 0) {
                        console.log(`Loading ${data.results.length} saved results`);
                        
                        // Add saved results to queue
                        data.results.forEach(savedVideo => {
                            // Check if not already in queue
                            const exists = videoQueue.find(v => v.id === savedVideo.id);
                            if (!exists) {
                                videoQueue.push({
                                    ...savedVideo,
                                    file: null  // File blob not saved, won't have original video
                                });
                            }
                        });
                        
                        renderVideoTable();
                        updateBatchSummary();
                        console.log('Results loaded successfully');
                    } else {
                        console.log('No saved results found');
                    }
                } else {
                    console.error('Failed to load results');
                }
            } catch (error) {
                console.error('Error loading results:', error);
            }
        }
        
        async function deleteResultFromPersistence(videoId) {
            try {
                const response = await fetch(`${API_URL}/results/${videoId}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    console.log(`Deleted result for video ${videoId}`);
                } else {
                    console.error('Failed to delete result');
                }
            } catch (error) {
                console.error('Error deleting result:', error);
            }
        }
        
        function removeVideo(videoId) {
            const index = videoQueue.findIndex(v => v.id === videoId);
            if (index !== -1) {
                const video = videoQueue[index];
                videoQueue.splice(index, 1);
                renderVideoTable();
                
                // Delete from persistent storage if it was completed
                if (video.status === 'completed') {
                    deleteResultFromPersistence(videoId);
                }
            }
        }
        
        function clearCompletedVideos() {
            videoQueue = videoQueue.filter(v => v.status !== 'completed' && v.status !== 'failed');
            renderVideoTable();
        }
        
        function setupCustomTimeline(video) {
            const videoPlayer = document.getElementById('pipelineVideoPlayer');
            const customTimeline = document.getElementById('customVideoTimeline');
            const timelineProgress = document.getElementById('timelineProgress');
            const timelineTrack = document.getElementById('timelineTrack');
            const currentTimeDisplay = document.getElementById('currentTimeDisplay');
            const durationDisplay = document.getElementById('durationDisplay');
            const violenceMarkersContainer = document.getElementById('violenceMarkersContainer');
            
            if (!video.result || !video.result.evidence || !video.result.evidence.violence) {
                customTimeline.style.display = 'none';
                return;
            }
            
            // Show custom timeline
            customTimeline.style.display = 'block';
            
            // Clear previous markers
            violenceMarkersContainer.innerHTML = '';
            
            // Get violence segments
            const violenceSegments = video.result.evidence.violence.filter(seg => seg.violence_score > 0.5);
            
            // Wait for video metadata to load
            videoPlayer.onloadedmetadata = () => {
                const duration = videoPlayer.duration;
                
                // Update duration display
                durationDisplay.textContent = formatTime(duration);
                
                // Create violence markers
                violenceSegments.forEach(segment => {
                    const startPercent = (segment.start_time / duration) * 100;
                    const endPercent = (segment.end_time / duration) * 100;
                    const widthPercent = endPercent - startPercent;
                    
                    const marker = document.createElement('div');
                    marker.style.position = 'absolute';
                    marker.style.left = `${startPercent}%`;
                    marker.style.width = `${Math.max(widthPercent, 1)}%`; // Minimum 1% width for visibility
                    marker.style.height = '100%';
                    marker.style.background = '#ff0000'; // Solid red for maximum visibility
                    marker.style.borderRadius = '4px';
                    marker.style.pointerEvents = 'none';
                    marker.style.zIndex = '10'; // High z-index to be in front
                    marker.style.boxShadow = '0 0 4px rgba(255, 0, 0, 0.8)'; // Glow effect
                    marker.title = `Violence: ${formatTime(segment.start_time)} - ${formatTime(segment.end_time)} (${(segment.violence_score * 100).toFixed(0)}%)`;
                    
                    violenceMarkersContainer.appendChild(marker);
                });
            };
            
            // Update progress as video plays
            videoPlayer.ontimeupdate = () => {
                const percent = (videoPlayer.currentTime / videoPlayer.duration) * 100;
                timelineProgress.style.width = `${percent}%`;
                currentTimeDisplay.textContent = formatTime(videoPlayer.currentTime);
            };
            
            // Seek on click
            timelineTrack.onclick = (e) => {
                const rect = timelineTrack.getBoundingClientRect();
                const percent = (e.clientX - rect.left) / rect.width;
                videoPlayer.currentTime = percent * videoPlayer.duration;
            };
        }
        
        function formatTime(seconds) {
            if (isNaN(seconds) || seconds === undefined) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        function renderVideoInRightPane(video) {
            const pipelineDetailContent = document.getElementById('pipelineDetailContent');
            const pipelineEmptyState = document.getElementById('pipelineEmptyState');
            
            pipelineEmptyState.style.display = 'none';
            pipelineDetailContent.style.display = 'block';
            
            // Store current viewing video
            currentViewingVideo = video.id;
            currentResults = video.result;
            currentAnalysisData = video.result;
            
            // Generate the full pipeline HTML (similar to existing pipelineViewPanel)
            const videoUrl = video.result && video.result.metadata && video.result.metadata.video_id ?
                `${API_URL}/video/labeled/${video.result.metadata.video_id}` :
                (video.file ? URL.createObjectURL(video.file) : '');
            
            pipelineDetailContent.innerHTML = `
                <!-- Circular Pipeline Stages -->
                <div style="padding: 15px 20px; background: var(--black); border-bottom: 1px solid var(--gray-medium);">
                    <div class="pipeline-stages" id="rightPanePipelineStages" style="display: flex; gap: 8px; justify-content: space-between; flex-wrap: nowrap;">
                        ${[
                            {id: 'ingest_video', num: '01', name: 'INGEST'},
                            {id: 'segment_video', num: '02', name: 'SEGMENT'},
                            {id: 'yolo26_vision', num: '03', name: 'VISION'},
                            {id: 'yoloworld_vision', num: '04', name: 'YOLO-W'},
                            {id: 'violence_detection', num: '05', name: 'VIOLENCE'},
                            {id: 'audio_transcription', num: '06', name: 'AUDIO'},
                            {id: 'ocr_extraction', num: '07', name: 'OCR'},
                            {id: 'text_moderation', num: '08', name: 'MODERATE'},
                            {id: 'policy_fusion', num: '09', name: 'SCORE'},
                            {id: 'report_generation', num: '10', name: 'REPORT'},
                            {id: 'finalize', num: '11', name: 'FINAL'}
                        ].map(stage => `
                            <div class="pipeline-stage" data-stage="${stage.id}" style="flex: 0 0 auto; text-align: center; cursor: pointer; min-width: 52px; max-width: 60px;">
                                <div class="stage-icon-wrapper" style="width: 40px; height: 40px; margin: 0 auto 6px; border-radius: 50%; background: var(--gray-dark); border: 2px solid var(--gray-medium); display: flex; align-items: center; justify-content: center; position: relative; transition: all 0.2s;">
                                    <div class="stage-number" style="font-size: 0.75em; font-weight: 600; color: var(--gray-light);">${stage.num}</div>
                                    <div class="stage-status" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; font-size: 1em; opacity: 0;">⟳</div>
                                </div>
                                <div class="stage-name" style="font-size: 0.6em; color: var(--gray-light); font-weight: 600; letter-spacing: 0.3px; line-height: 1.2;">${stage.name}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                
                <!-- Main Content: Side-by-Side Video + Output -->
                <div style="display: grid; grid-template-columns: 1.2fr 1fr; gap: 15px; padding: 15px; height: calc(100% - 80px); overflow: hidden;">
                    <!-- Video Player (60%) -->
                    <div style="display: flex; flex-direction: column; height: 100%;">
                        <!-- Video Type Toggle -->
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; flex-shrink: 0;">
                            <div style="font-size: 0.6em; font-weight: 600; letter-spacing: 1px; color: var(--gray-light); text-transform: uppercase;">Video Preview</div>
                            ${video.result ? `
                                <div style="display: flex; gap: 4px; background: var(--gray-dark); border-radius: 4px; padding: 2px;">
                                    <button onclick="switchVideoType('labeled')" id="labeledVideoBtn" style="padding: 4px 10px; font-size: 0.6em; font-weight: 600; border: none; background: var(--primary); color: var(--black); border-radius: 3px; cursor: pointer; transition: all 0.2s;">
                                        LABELED
                                    </button>
                                    <button onclick="switchVideoType('original')" id="originalVideoBtn" style="padding: 4px 10px; font-size: 0.6em; font-weight: 600; border: none; background: transparent; color: var(--gray-light); border-radius: 3px; cursor: pointer; transition: all 0.2s;">
                                        ORIGINAL
                                    </button>
                                </div>
                            ` : ''}
                        </div>
                        <!-- Flexible Video Container -->
                        <div style="flex: 1; max-height: 450px; background: #000; border-radius: 4px; overflow: hidden; display: flex; align-items: center; justify-content: center; min-height: 0;">
                            <video id="rightPaneVideoPlayer" controls style="width: 100%; height: 100%; object-fit: contain; display: block;">
                                ${videoUrl ? `<source src="${videoUrl}" type="video/mp4">` : ''}
                                Your browser does not support video playback.
                            </video>
                        </div>
                    </div>
                    
                    <!-- Stage Output (40%) -->
                    <div style="display: flex; flex-direction: column; height: 100%;">
                        <div style="font-size: 0.6em; font-weight: 600; letter-spacing: 1px; color: var(--gray-light); margin-bottom: 8px; text-transform: uppercase; flex-shrink: 0;">Stage Output</div>
                        <div id="rightPaneStageOutput" style="flex: 1; max-height: 450px; background: var(--gray-dark); border: 1px solid var(--gray-medium); border-radius: 4px; padding: 12px; overflow-y: auto; font-size: 0.9em; min-height: 0;">
                            ${video.result ? generateCompactResultsSummary(video.result) : `<div style="text-align: center; padding: 25px 12px; color: var(--gray-light); font-size: 0.9em;">Click a stage above to view details</div>`}
                        </div>
                    </div>
                </div>
            `;
            
            // Update pipeline stages based on video status
            if (video.status === 'processing') {
                // Show live progress
                updatePipelineStagesInRightPane(video);
            } else if (video.status === 'completed' && video.result) {
                // Mark all stages as complete
                markAllStagesCompleteInRightPane();
            }
            
            // Attach click handlers to stages in right pane
            document.querySelectorAll('#rightPanePipelineStages .pipeline-stage').forEach(stage => {
                stage.addEventListener('click', () => {
                    const stageName = stage.getAttribute('data-stage');
                    showStageOutputInRightPane(stageName, video);
                    
                    // Highlight active stage
                    document.querySelectorAll('#rightPanePipelineStages .pipeline-stage').forEach(s => {
                        s.style.opacity = '0.6';
                    });
                    stage.style.opacity = '1';
                });
            });
        }
        
        function updatePipelineStagesInRightPane(video) {
            // Update stages for in-progress videos
            const currentStage = video.currentStage || '';
            const progress = video.progress || 0;
            
            const stageProgressMap = {
                'ingest_video': 5,
                'segment_video': 10,
                'yolo26_vision': 25,
                'yoloworld_vision': 30,
                'violence_detection': 40,
                'audio_transcription': 55,
                'ocr_extraction': 65,
                'text_moderation': 75,
                'policy_fusion': 85,
                'report_generation': 95,
                'finalize': 100
            };
            
            document.querySelectorAll('#rightPanePipelineStages .pipeline-stage').forEach(stageEl => {
                const stageName = stageEl.getAttribute('data-stage');
                const stageProgress = stageProgressMap[stageName] || 0;
                const wrapper = stageEl.querySelector('.stage-icon-wrapper');
                const statusEl = stageEl.querySelector('.stage-status');
                const numberEl = stageEl.querySelector('.stage-number');
                
                if (progress >= stageProgress + 5) {
                    // Completed
                    wrapper.style.borderColor = '#00aa00';
                    wrapper.style.background = 'rgba(0, 170, 0, 0.1)';
                    statusEl.textContent = '✓';
                    statusEl.style.color = '#00aa00';
                    statusEl.style.opacity = '1';
                    statusEl.style.animation = 'none';  // ← Remove spinner animation!
                    numberEl.style.opacity = '0';
                } else if (stageName === currentStage || Math.abs(progress - stageProgress) < 5) {
                    // In progress
                    wrapper.style.borderColor = '#00aaff';
                    wrapper.style.background = 'rgba(0, 170, 255, 0.1)';
                    statusEl.textContent = '⟳';
                    statusEl.style.color = '#00aaff';
                    statusEl.style.opacity = '1';
                    statusEl.style.animation = 'spin 2s linear infinite';
                    numberEl.style.opacity = '0';
                } else {
                    // Pending
                    wrapper.style.borderColor = 'var(--gray-medium)';
                    wrapper.style.background = 'var(--gray-dark)';
                    statusEl.style.opacity = '0';
                    statusEl.style.animation = 'none';  // ← Clear any animation
                    numberEl.style.opacity = '1';
                }
            });
        }
        
        function markAllStagesCompleteInRightPane() {
            document.querySelectorAll('#rightPanePipelineStages .pipeline-stage').forEach(stage => {
                const wrapper = stage.querySelector('.stage-icon-wrapper');
                const statusEl = stage.querySelector('.stage-status');
                const numberEl = stage.querySelector('.stage-number');
                
                wrapper.style.borderColor = '#00aa00';
                wrapper.style.background = 'rgba(0, 170, 0, 0.1)';
                statusEl.textContent = '✓';
                statusEl.style.color = '#00aa00';
                statusEl.style.opacity = '1';
                statusEl.style.animation = 'none';  // ← Remove any animations!
                numberEl.style.opacity = '0';
            });
        }
        
        function showResultsInRightPane(result) {
            // Show initial results summary
            const outputDiv = document.getElementById('rightPaneStageOutput');
            if (outputDiv) {
                outputDiv.innerHTML = `
                    <div style="text-align: center; padding: 20px;">
                        <div style="font-size: 1.5em; margin-bottom: 15px;">
                            <span class="verdict-badge verdict-${result.verdict.toLowerCase()}" style="font-size: 1em; padding: 8px 16px;">
                                ${result.verdict}
                            </span>
                        </div>
                        <div style="color: var(--gray-light); font-size: 0.9em; margin-bottom: 20px;">
                            Click on any stage above to view detailed output
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-top: 20px;">
                            ${Object.entries(result.criteria || {}).map(([key, value]) => `
                                <div style="background: var(--black); padding: 15px; border-radius: 4px;">
                                    <div style="font-size: 0.7em; color: var(--gray-light); text-transform: uppercase; margin-bottom: 5px;">${key.replace(/_/g, ' ')}</div>
                                    <div style="font-size: 1.2em; font-weight: 600;">${Math.round(value * 100)}%</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }
        }
        
        function generateCompactResultsSummary(result) {
            // Debug log to check result structure
            console.log('Generating summary for result:', result);
            console.log('Criteria:', result.criteria);
            
            return `
                <div style="text-align: center; margin-bottom: 12px;">
                    <div style="font-size: 0.65em; color: var(--gray-light); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 6px;">VERDICT</div>
                    <span class="verdict-badge verdict-${result.verdict.toLowerCase()}" style="font-size: 0.9em; padding: 5px 12px;">
                        ${result.verdict}
                    </span>
                </div>
                
                <div style="background: var(--black); border-radius: 4px; padding: 10px; margin-bottom: 12px;">
                    <div style="font-size: 0.55em; color: var(--gray-light); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">CRITERIA SCORES</div>
                    <div style="display: grid; grid-template-columns: 1fr; gap: 8px;">
                        ${Object.entries(result.criteria || {}).map(([key, value]) => {
                            // Handle all possible formats
                            let score = 0;
                            if (typeof value === 'number') {
                                score = value;
                            } else if (typeof value === 'object' && value !== null) {
                                score = value.score || value.value || 0;
                            } else {
                                score = parseFloat(value) || 0;
                            }
                            
                            const percentage = Math.round(score * 100);
                            const color = percentage > 70 ? '#ff0000' : percentage > 40 ? '#ffaa00' : '#00aa00';
                            return `
                                <div style="background: var(--gray-dark); padding: 8px; border-radius: 3px; border-left: 2px solid ${color};">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                        <div style="font-size: 0.65em; color: var(--gray-light); text-transform: uppercase;">${key.replace(/_/g, ' ')}</div>
                                        <div style="font-size: 1em; font-weight: 600; color: ${color};">${percentage}%</div>
                                    </div>
                                    <div style="height: 3px; background: rgba(255,255,255,0.1); border-radius: 2px; overflow: hidden;">
                                        <div style="height: 100%; background: ${color}; width: ${percentage}%; transition: width 0.3s;"></div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
                
                <div style="text-align: center; padding: 8px; background: rgba(0, 170, 255, 0.1); border-radius: 3px; border: 1px solid rgba(0, 170, 255, 0.3);">
                    <svg width="12" height="12" viewBox="0 0 16 16" fill="currentColor" style="vertical-align: middle; margin-right: 5px; color: var(--primary);">
                        <path d="M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0zm1 12H7V7h2v5zm0-6H7V4h2v2z"/>
                    </svg>
                    <span style="font-size: 0.7em; color: var(--primary);">Click stage above for details</span>
                </div>
            `;
        }
        
        function showStageOutputInRightPane(stageName, video) {
            const outputDiv = document.getElementById('rightPaneStageOutput');
            if (!outputDiv || !video.result) return;
            
            // Use existing stage output generation logic
            const content = generateStageContent(stageName, video.result);
            outputDiv.innerHTML = content;
        }
        
        function viewVideoReport(videoId) {
            const video = videoQueue.find(v => v.id === videoId);
            if (!video) return;
            
            // Check if we're in split-pane mode (file tree view)
            const splitPane = document.getElementById('splitPaneContainer');
            const inSplitPaneMode = splitPane && splitPane.style.display === 'flex';
            
            if (inSplitPaneMode) {
                // Render in the right pane instead of switching views
                renderVideoInRightPane(video);
                return;
            }
            
            // Original behavior - switch to pipeline view
            // Handle in-progress videos (no result yet)
            if (video.status === 'processing' && !video.result) {
                // Store current video reference
                currentViewingVideo = video;
                
                // Hide batch panel, show pipeline view
                document.getElementById('batchPanel').style.display = 'none';
                document.getElementById('pipelineViewPanel').style.display = 'block';
                
                // Update title
                document.getElementById('pipelineVideoTitle').textContent = `PIPELINE: ${video.filename} (LIVE)`;
                
                // Setup video player in pipeline view with original video
                const pipelineVideoPlayer = document.getElementById('pipelineVideoPlayer');
                if (video.file) {
                    pipelineVideoPlayer.src = URL.createObjectURL(video.file);
                } else {
                    // If file not available, try to load from backend
                    if (video.batchVideoId) {
                        const originalVideoUrl = `${API_URL}/video/uploaded/${video.batchVideoId}`;
                        pipelineVideoPlayer.src = originalVideoUrl;
                    }
                }
                
                // Update stage output with current progress immediately
                updateStageOutputForInProgress(video);
                
                // Update pipeline stage indicators immediately
                if (video.currentStage) {
                    updatePipelineStagesLive({
                        stage: video.currentStage,
                        progress: video.progress || 0,
                        message: 'Processing...'
                    });
                }
                
                // Switch to PIPELINE tab
                document.querySelectorAll('.sidebar-link').forEach(l => l.classList.remove('active'));
                const pipelineTab = document.querySelector('.sidebar-link[data-tab="pipeline"]');
                if (pipelineTab) pipelineTab.classList.add('active');
                document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
                document.getElementById('pipeline').classList.add('active');
                
                return;
            }
            
            // Handle completed videos (with results)
            if (!video.result) return;
            
            // Store current video reference
            currentViewingVideo = video;
            currentResults = video.result;
            currentAnalysisData = video.result;
            
            // Update Analytics tab to show this video's results
            document.getElementById('batchAnalytics').style.display = 'none';
            document.getElementById('analyticsResults').style.display = 'block';
            
            // Populate the analytics display
            populateIndividualAnalytics(video);
            
            // Hide batch panel, show pipeline view
            document.getElementById('batchPanel').style.display = 'none';
            document.getElementById('pipelineViewPanel').style.display = 'block';
            
            // Update title
            document.getElementById('pipelineVideoTitle').textContent = `PIPELINE: ${video.filename}`;
            
            // Setup video player in pipeline view
            // Use labeled video if available, otherwise use original
            const pipelineVideoPlayer = document.getElementById('pipelineVideoPlayer');
            if (video.result && video.result.metadata && video.result.metadata.video_id) {
                // Try to load labeled video from backend
                const videoId = video.result.metadata.video_id;
                const labeledVideoUrl = `${API_URL}/video/labeled/${videoId}`;
                
                console.log(`Attempting to load labeled video: ${labeledVideoUrl}`);
                
                // Try labeled video first, fallback to original on error
                pipelineVideoPlayer.src = labeledVideoUrl;
                pipelineVideoPlayer.onerror = () => {
                    console.warn(`Labeled video failed to load, using original video`);
                    if (video.file) {
                        pipelineVideoPlayer.src = URL.createObjectURL(video.file);
                    }
                };
                pipelineVideoPlayer.onloadeddata = () => {
                    console.log(`Video loaded successfully: ${pipelineVideoPlayer.src}`);
                };
            } else if (video.file) {
                console.log('No video_id found, using original video file');
                pipelineVideoPlayer.src = URL.createObjectURL(video.file);
            }
            
            // Populate the pipeline stages
            populatePipelineStages(video.result);
            
            // Setup custom timeline with violence markers
            setupCustomTimeline(video);
            
            // Update progress bar
            const progressFill = document.getElementById('progressFill');
            if (progressFill) {
                progressFill.style.width = '100%';
            }
            
            // Switch to PIPELINE tab
            document.querySelectorAll('.sidebar-link').forEach(l => l.classList.remove('active'));
            document.querySelector('.sidebar-link[data-tab="pipeline"]').classList.add('active');
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.getElementById('pipeline').classList.add('active');
            
            // Scroll to top
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
        
        function populatePipelineStages(videoOrResult) {
            // Handle both in-progress videos (video object) and completed videos (result object)
            const isInProgress = videoOrResult.status === 'processing';
            const result = isInProgress ? null : videoOrResult;
            const video = isInProgress ? videoOrResult : null;
            
            const stages = [
                'ingest_video',
                'segment_video', 
                'yolo26_vision',
                'yoloworld_vision',  // NEW - Added as separate stage
                'violence_detection',
                'audio_transcription',
                'ocr_extraction',
                'text_moderation',
                'policy_fusion',
                'report_generation',
                'finalize'
            ];
            
            const stageNames = {
                'ingest_video': 'Ingest Video',
                'segment_video': 'Segment Video',
                'yolo26_vision': 'YOLO26 Vision',
                'yoloworld_vision': 'YOLO-World Vision',  // NEW
                'violence_detection': 'Violence Detection',
                'audio_transcription': 'Audio Transcription',
                'ocr_extraction': 'OCR Extraction',
                'text_moderation': 'Text Moderation',
                'policy_fusion': 'Policy Fusion',
                'report_generation': 'Report Generation',
                'finalize': 'Finalize'
            };
            
            // For in-progress videos, show progress
            if (isInProgress) {
                const currentStageIndex = stages.indexOf(video.currentStage);
                
                // Show default content for first stage
                const stageOutputContent = document.getElementById('stageOutputContent');
                stageOutputContent.innerHTML = `
                    <div style="padding: 20px; text-align: center;">
                        <div style="font-size: 2em; margin-bottom: 20px; animation: spin 2s linear infinite;">⟳</div>
                        <div style="font-size: 1.2em; margin-bottom: 10px;">Processing In Progress</div>
                        <div style="color: var(--gray-light); margin-bottom: 20px;">
                            Stage: <strong>${formatStageName(video.currentStage || 'unknown')}</strong><br>
                            Progress: <strong>${video.progress || 0}%</strong>
                        </div>
                        <div style="padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px; margin-top: 20px; text-align: left; font-family: 'Courier New', monospace; font-size: 0.9em;">
                            Watch this space for real-time updates as the video progresses through each pipeline stage.
                        </div>
                    </div>
                `;
            } else {
                // For completed videos, show first stage by default
                showStageDetails('ingest_video');
            }
        }
        
        function formatStageName(stage) {
            const names = {
                'ingest_video': 'Video Ingestion',
                'segment_video': 'Video Segmentation',
                'yolo26_vision': 'Vision Analysis',
                'yoloworld_vision': 'Open-Vocab Vision',  // NEW
                'violence_detection': 'Violence Detection',
                'audio_transcription': 'Audio Transcription',
                'ocr_extraction': 'OCR Extraction',
                'text_moderation': 'Text Moderation',
                'policy_fusion': 'Policy Fusion',
                'report_generation': 'Report Generation',
                'finalize': 'Finalization'
            };
            return names[stage] || stage;
        }
        
        function updateStageOutputForInProgress(video) {
            const stageOutputContent = document.getElementById('stageOutputContent');
            if (!stageOutputContent) return;
            
            stageOutputContent.innerHTML = `
                <div style="padding: 20px; text-align: center;">
                    <div style="font-size: 2em; margin-bottom: 20px; animation: spin 2s linear infinite;">⟳</div>
                    <div style="font-size: 1.2em; margin-bottom: 10px;">Processing In Progress</div>
                    <div style="color: var(--gray-light); margin-bottom: 20px;">
                        Stage: <strong>${formatStageName(video.currentStage || 'starting')}</strong><br>
                        Progress: <strong>${video.progress || 0}%</strong>
                    </div>
                    <div style="padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px; margin-top: 20px; text-align: left; font-family: 'Courier New', monospace; font-size: 0.9em;">
                        ${video.statusMessage || 'Watch this space for real-time updates as the video progresses through each pipeline stage.'}
                    </div>
                </div>
            `;
        }
        
        function populateIndividualAnalytics(video) {
            const data = video.result;
            if (!data) return;
            
            // Verdict
            const verdictBadge = document.getElementById('verdictBadge');
            verdictBadge.textContent = data.verdict;
            verdictBadge.className = `verdict-badge verdict-${data.verdict.toLowerCase()}`;

            // Verdict description
            const verdictDescriptions = {
                'SAFE': 'Content appears suitable for viewing based on safety criteria',
                'CAUTION': 'Content contains moderate indicators requiring supervision',
                'UNSAFE': 'Content contains significant violations and is not recommended',
                'NEEDS_REVIEW': 'Manual review recommended for final determination'
            };
            document.getElementById('verdictDescription').textContent = verdictDescriptions[data.verdict] || '';

            // Stats
            const statsGrid = document.getElementById('statsGrid');
            if (data.metadata) {
                statsGrid.innerHTML = `
                    <div class="stat-card">
                        <div class="stat-label">Duration</div>
                        <div class="stat-value">${data.metadata.duration?.toFixed(1)}s</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Violations</div>
                        <div class="stat-value">${data.violations?.length || 0}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Frames</div>
                        <div class="stat-value">${data.metadata.frames_analyzed || '—'}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Processing Time</div>
                        <div class="stat-value">${data.metadata.processing_time?.toFixed(1)}s</div>
                    </div>
                `;
            }

            // Criteria grid
            populateCriteriaGrid(data);
            
            // Model contributions
            populateModelContributions(data);
            
            // Violations list
            if (data.violations && data.violations.length > 0) {
                document.getElementById('violationsPanel').style.display = 'block';
                populateViolationsList(data.violations);
            } else {
                document.getElementById('violationsPanel').style.display = 'none';
            }
            
            // Report
            const reportContent = document.getElementById('reportContent');
            if (data.report) {
                reportContent.innerHTML = marked.parse(data.report);
            } else {
                reportContent.innerHTML = '<div style="text-align: center; color: var(--gray-light); padding: 20px;">No AI report available</div>';
            }
            
            // Setup video player if available
            const videoPlayer = document.getElementById('videoPlayer');
            
            // Try to use labeled video if available
            if (video.result && video.result.metadata && video.result.metadata.video_id) {
                const videoId = video.result.metadata.video_id;
                const labeledVideoUrl = `${API_URL}/video/labeled/${videoId}`;
                
                console.log(`Analytics: Attempting to load labeled video: ${labeledVideoUrl}`);
                
                // Try labeled video first, fallback to original on error
                videoPlayer.src = labeledVideoUrl;
                videoPlayer.onerror = () => {
                    console.warn(`Analytics: Labeled video failed to load, using original video`);
                    if (video.file) {
                        videoPlayer.src = URL.createObjectURL(video.file);
                    }
                };
                videoPlayer.onloadeddata = () => {
                    console.log(`Analytics: Video loaded successfully: ${videoPlayer.src}`);
                };
            } else if (video.file) {
                console.log('Analytics: No video_id found, using original video file');
                videoPlayer.src = URL.createObjectURL(video.file);
            }
            
            // Timeline markers (only if we have video loaded)
            if (video.file || (video.result && video.result.metadata && video.result.metadata.video_id)) {
                if (data.violations && data.violations.length > 0 && data.metadata?.duration) {
                    const markers = document.getElementById('timelineMarkers');
                    markers.innerHTML = data.violations
                        .filter(v => v.timestamp)
                        .map(v => {
                            const position = (v.timestamp / data.metadata.duration) * 100;
                            return `<div class="timeline-marker" style="left: ${position}%;" title="${v.criterion} at ${v.timestamp.toFixed(1)}s"></div>`;
                        })
                        .join('');
                }
            }
        }
        
        function populateCriteriaGrid(data) {
            const criteriaGrid = document.getElementById('criteriaGrid');
            if (!criteriaGrid || !data.criteria) return;
            
            criteriaGrid.innerHTML = '';
            
            Object.entries(data.criteria).forEach(([name, info]) => {
                const score = info.score.toFixed(2);
                const percentage = Math.round(info.score * 100);
                const status = info.score < 0.3 ? 'safe' : info.score < 0.6 ? 'caution' : 'unsafe';
                const statusLabel = info.score < 0.3 ? 'LOW' : info.score < 0.6 ? 'MODERATE' : 'HIGH';
                
                const card = document.createElement('div');
                card.className = `criterion-analysis-card score-${status}`;
                card.innerHTML = `
                    <div class="criterion-analysis-name">${name.replace(/_/g, ' ')}</div>
                    <div class="criterion-analysis-score">${percentage}%</div>
                    <div class="criterion-analysis-label">${statusLabel}</div>
                    <div style="font-size: 0.75em; color: var(--gray-light); margin-top: 4px;">${score}</div>
                `;
                card.title = `${name}: ${percentage}% confidence (independent metric)`;
                criteriaGrid.appendChild(card);
            });
            
            // Add explanation note if not already present
            const existingNote = document.querySelector('.criteria-explanation-note');
            if (!existingNote) {
                const note = document.createElement('div');
                note.className = 'criteria-explanation-note';
                note.style.cssText = 'grid-column: 1 / -1; padding: 12px; background: rgba(255,255,255,0.05); border-radius: 6px; font-size: 0.85em; color: var(--gray-light); text-align: center; margin-top: 10px;';
                note.innerHTML = `
                    <strong>Note:</strong> Each criterion is evaluated independently (0-100% confidence). 
                    These scores don't add up to 100% - high violence score doesn't mean low profanity, etc.
                `;
                criteriaGrid.appendChild(note);
            }
        }
        
        function populateViolationsList(violations) {
            const violationsList = document.getElementById('violationsList');
            if (!violationsList) return;
            
            violationsList.innerHTML = '';
            
            violations.forEach(violation => {
                const item = document.createElement('div');
                item.className = 'violation-item';
                
                const timeRanges = violation.timestamp_ranges && violation.timestamp_ranges.length > 0 
                    ? violation.timestamp_ranges.map(r => `${r[0].toFixed(1)}-${r[1].toFixed(1)}s`).join(', ')
                    : 'Throughout video';
                
                item.innerHTML = `
                    <div class="violation-time">${timeRanges}</div>
                    <div class="violation-details">
                        <div class="violation-criterion">${violation.criterion.replace(/_/g, ' ')}</div>
                        <div style="color: var(--gray-light); font-size: 0.9em;">
                            Confidence: ${(violation.score * 100).toFixed(0)}% • ${violation.evidence_refs?.length || 0} evidence point(s)
                        </div>
                        <div class="violation-severity ${violation.severity}">${violation.severity} severity</div>
                    </div>
                `;
                violationsList.appendChild(item);
            });
        }
        
        function populatePipelineStages(result) {
            const stages = document.querySelectorAll('.pipeline-stage');
            
            // Mark all stages as completed since we have final results
            stages.forEach(stage => {
                const stageIcon = stage.querySelector('.stage-status');
                const stageName = stage.getAttribute('data-stage');
                
                // Mark as completed
                stage.classList.add('completed');
                stage.classList.remove('active', 'pending');
                if (stageIcon) {
                    stageIcon.textContent = '✓';
                    stageIcon.style.color = '#00aa00';
                }
                
                // Make clickable to view stage output
                stage.style.cursor = 'pointer';
                stage.onclick = () => showStageOutput(stageName, result);
            });
            
            // Stage description element removed from UI (was part of "CURRENT STAGE" section)
            // No longer needed
        }
        
        function resetPipelineStages() {
            const stages = document.querySelectorAll('.pipeline-stage');
            stages.forEach(stage => {
                stage.classList.remove('completed', 'active');
                stage.classList.add('pending');
                const stageIcon = stage.querySelector('.stage-status');
                if (stageIcon) {
                    stageIcon.textContent = '⟳';
                    stageIcon.style.color = '';
                }
                stage.style.cursor = 'default';
                stage.onclick = null;
            });
        }
        
        function showStageOutput(stageName, result) {
            const outputSection = document.getElementById('stageOutputSection');
            const outputTitle = document.getElementById('stageOutputTitle');
            const outputContent = document.getElementById('stageOutputContent');
            
            if (!outputSection || !outputTitle || !outputContent) return;
            
            // Map stage names to output content
            const stageOutputs = {
                'ingest_video': {
                    title: 'VIDEO INGEST',
                    content: `
                        <div style="margin-bottom: 15px;">
                            <strong>Video Metadata:</strong><br>
                            <div style="background: var(--black); padding: 15px; margin-top: 10px;">
                                <div style="display: grid; grid-template-columns: 150px 1fr; gap: 8px;">
                                    <div style="color: var(--gray-light);">Duration:</div>
                                    <div>${result.metadata?.duration?.toFixed(2) || '0'}s</div>
                                    
                                    <div style="color: var(--gray-light);">Resolution:</div>
                                    <div>${result.metadata?.width || 0} × ${result.metadata?.height || 0}</div>
                                    
                                    <div style="color: var(--gray-light);">Frame Rate:</div>
                                    <div>${result.metadata?.fps?.toFixed(2) || 0} fps</div>
                                    
                                    <div style="color: var(--gray-light);">Audio:</div>
                                    <div>${result.metadata?.has_audio ? '✓ Present' : '✗ None'}</div>
                                    
                                    <div style="color: var(--gray-light);">Video ID:</div>
                                    <div style="font-family: monospace; font-size: 0.85em;">${result.metadata?.video_id || 'N/A'}</div>
                                </div>
                            </div>
                        </div>
                    `
                },
                'segment_video': {
                    title: 'VIDEO SEGMENTATION',
                    content: `
                        <div style="margin-bottom: 15px;">
                            <strong>Frame Sampling:</strong><br>
                            <div style="background: var(--black); padding: 15px; margin-top: 10px;">
                                <div style="display: grid; grid-template-columns: 150px 1fr; gap: 8px;">
                                    <div style="color: var(--gray-light);">Frames Analyzed:</div>
                                    <div>${result.metadata?.frames_analyzed || 0} frames</div>
                                    
                                    <div style="color: var(--gray-light);">Sampling Rate:</div>
                                    <div>1 frame per second (1 fps)</div>
                                    
                                    <div style="color: var(--gray-light);">Segments Created:</div>
                                    <div>${result.metadata?.segments_analyzed || 0} segments</div>
                                    
                                    <div style="color: var(--gray-light);">Coverage:</div>
                                    <div>${result.metadata?.duration ? Math.min(100, ((result.metadata?.frames_analyzed || 0) / result.metadata.duration * 100)).toFixed(1) : 0}% of video analyzed</div>
                                </div>
                            </div>
                        </div>
                    `
                },
                'yolo26_vision': {
                    title: 'YOLO26 OBJECT DETECTION',
                    content: generateYoloOutput(result.evidence?.vision || [], result.metadata)
                },
                'yoloworld_vision': {  // NEW
                    title: 'YOLO-WORLD OPEN-VOCABULARY DETECTION',
                    content: generateYoloWorldOutput(result.yoloworld_detections || result.evidence?.yoloworld || [], result.metadata)
                },
                'violence_detection': {
                    title: 'VIOLENCE DETECTION (X-CLIP)',
                    content: generateViolenceOutput(result.evidence?.violence_segments || [])
                },
                'audio_transcription': {
                    title: 'AUDIO TRANSCRIPTION (WHISPER)',
                    content: `
                        <div style="margin-bottom: 15px;">
                            ${result.transcript?.text || result.transcript?.full_text ? `
                                <div style="background: var(--gray-dark); padding: 20px; border-left: 3px solid var(--white); margin-bottom: 15px;">
                                    <strong style="display: block; margin-bottom: 12px; color: var(--white); font-size: 1.1em;">Full Transcript:</strong>
                                    <div style="line-height: 1.8; color: var(--gray-light); font-size: 1.05em;">
                                        ${result.transcript?.text || result.transcript?.full_text}
                                    </div>
                                </div>
                            ` : ''}
                            ${result.transcript?.chunks && result.transcript.chunks.length > 0 ? `
                                <strong style="display: block; margin-bottom: 10px; color: var(--white);">Timestamped Segments (${result.transcript.chunks.length}):</strong>
                                <div style="max-height: 300px; overflow-y: auto;">
                                    ${result.transcript.chunks.slice(0, 10).map((chunk, idx) => `
                                        <div style="background: var(--black); padding: 12px; margin-bottom: 8px; border-left: 2px solid var(--blue);">
                                            <div style="color: var(--gray-light); font-size: 0.85em; margin-bottom: 6px;">
                                                Segment ${idx + 1}: ${chunk.start_time != null ? chunk.start_time.toFixed(1) + 's' : 'N/A'} - ${chunk.end_time != null ? chunk.end_time.toFixed(1) + 's' : 'N/A'}
                                            </div>
                                            <div style="color: var(--white);">${chunk.text}</div>
                                        </div>
                                    `).join('')}
                                    ${result.transcript.chunks.length > 10 ? `<div style="text-align: center; color: var(--gray-light); padding: 10px;">... and ${result.transcript.chunks.length - 10} more segments</div>` : ''}
                                </div>
                            ` : '<div style="color: var(--gray-light); padding: 15px; background: var(--gray-darker);">No speech detected in audio</div>'}
                        </div>
                    `
                },
                'ocr_extraction': {
                    title: 'OCR TEXT EXTRACTION',
                    content: generateOcrOutput(result.evidence?.ocr || [])
                },
                'text_moderation': {
                    title: 'TEXT MODERATION',
                    content: generateModerationOutput(result.evidence?.transcript_moderation || [])
                },
                'policy_fusion': {
                    title: 'POLICY & SCORING',
                    content: generateScoringOutput(result.criteria || result.scores || {})
                },
                'report_generation': {
                    title: 'AI REPORT GENERATION',
                    content: generateReportOutput(result.report)
                },
                'finalize': {
                    title: 'FINALIZATION',
                    content: `
                        <div style="margin-bottom: 15px;">
                            <strong>Pipeline Complete</strong><br>
                            <div style="background: var(--black); padding: 15px; margin-top: 10px;">
                                <div style="display: grid; grid-template-columns: 150px 1fr; gap: 8px;">
                                    <div style="color: var(--gray-light);">Final Verdict:</div>
                                    <div style="color: ${getVerdictColor(result.verdict)}; font-weight: bold; font-size: 1.1em;">${result.verdict}</div>
                                    
                                    <div style="color: var(--gray-light);">Processing Time:</div>
                                    <div>${result.metadata?.processing_time ? result.metadata.processing_time.toFixed(2) + 's' : result.timings?.total_seconds?.toFixed(2) + 's' || 'N/A'}</div>
                                    
                                    <div style="color: var(--gray-light);">Total Frames:</div>
                                    <div>${result.metadata?.frames_analyzed || 0}</div>
                                    
                                    <div style="color: var(--gray-light);">Detections:</div>
                                    <div>${result.metadata?.detections_count || 0}</div>
                                    
                                    <div style="color: var(--gray-light);">Violations:</div>
                                    <div style="color: ${result.violations?.length > 0 ? '#ff4444' : 'inherit'};">${result.violations?.length || 0}</div>
                                    
                                    <div style="color: var(--gray-light);">Timestamp:</div>
                                    <div style="font-size: 0.85em; font-family: monospace;">${new Date().toISOString()}</div>
                                </div>
                                
                                ${result.timings?.operations ? `
                                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--gray-dark);">
                                        <strong style="display: block; margin-bottom: 8px;">Stage Timings:</strong>
                                        ${Object.entries(result.timings.operations).map(([stage, time]) => 
                                            `<div style="display: flex; justify-content: space-between; padding: 3px 0;">
                                                <span style="color: var(--gray-light);">${stage}:</span>
                                                <span>${time}s</span>
                                            </div>`
                                        ).join('')}
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                    `
                }
            };
            
            const output = stageOutputs[stageName] || { title: stageName.toUpperCase(), content: '<p>No output available</p>' };
            
            outputTitle.textContent = output.title;
            outputContent.innerHTML = output.content;
            outputSection.style.display = 'block';
            
            // Scroll to output section
            outputSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
        
        function generateYoloOutput(visionData, metadata) {
            if (!visionData || visionData.length === 0) {
                return '<p style="color: var(--gray-light);">No objects detected in analyzed frames</p>';
            }
            
            const objectCounts = {};
            const categoryGroups = {
                weapon: [],
                substance: [],
                person: [],
                other: []
            };
            
            visionData.forEach(item => {
                const label = item.label || item.class || 'Unknown';
                objectCounts[label] = (objectCounts[label] || 0) + 1;
                
                const category = item.category || 'other';
                if (!categoryGroups[category]) categoryGroups[category] = [];
                categoryGroups[category].push(item);
            });
            
            const weaponCount = categoryGroups.weapon.length;
            const substanceCount = categoryGroups.substance.length;
            const personCount = categoryGroups.person.length;
            
            return `
                <div style="margin-bottom: 15px;">
                    <strong>Detection Summary:</strong><br>
                    <div style="background: var(--black); padding: 15px; margin-top: 10px;">
                        <div style="display: grid; grid-template-columns: 150px 1fr; gap: 8px; margin-bottom: 15px;">
                            <div style="color: var(--gray-light);">Total Detections:</div>
                            <div>${visionData.length} objects</div>
                            
                            <div style="color: var(--gray-light);">Frames Analyzed:</div>
                            <div>${metadata?.frames_analyzed || 0} frames</div>
                            
                            <div style="color: var(--gray-light);">⚠️ Weapons:</div>
                            <div style="color: ${weaponCount > 0 ? '#ff4444' : 'inherit'};">${weaponCount}</div>
                            
                            <div style="color: var(--gray-light);">⚠️ Substances:</div>
                            <div style="color: ${substanceCount > 0 ? '#ff8800' : 'inherit'};">${substanceCount}</div>
                            
                            <div style="color: var(--gray-light);">👤 Persons:</div>
                            <div>${personCount}</div>
                        </div>
                        
                        <strong style="display: block; margin-top: 10px; margin-bottom: 8px;">Object Breakdown:</strong>
                        <div style="max-height: 200px; overflow-y: auto;">
                            ${Object.entries(objectCounts)
                                .sort((a, b) => b[1] - a[1])
                                .map(([label, count]) => 
                                    `<div style="padding: 5px 0; border-bottom: 1px solid var(--gray-dark);">
                                        <span style="color: var(--gray-light);">${label}:</span> <strong>${count}</strong>
                                    </div>`
                                ).join('')}
                        </div>
                    </div>
                </div>
            `;
        }
        
        function generateYoloWorldOutput(yoloworldData, metadata) {
            if (!yoloworldData || yoloworldData.length === 0) {
                return '<p style="color: var(--gray-light);">No custom prompts matched in analyzed frames</p>';
            }
            
            const matchedPrompts = [...new Set(yoloworldData.map(d => d.prompt_match || d.label))];
            const promptCounts = {};
            const promptCategories = {};
            
            yoloworldData.forEach(d => {
                const prompt = d.prompt_match || d.label;
                promptCounts[prompt] = (promptCounts[prompt] || 0) + 1;
                
                if (!promptCategories[prompt]) {
                    promptCategories[prompt] = {
                        category: d.category || 'other',
                        avgConfidence: 0,
                        count: 0
                    };
                }
                promptCategories[prompt].avgConfidence += d.confidence;
                promptCategories[prompt].count++;
            });
            
            // Calculate averages
            Object.keys(promptCategories).forEach(prompt => {
                promptCategories[prompt].avgConfidence = 
                    promptCategories[prompt].avgConfidence / promptCategories[prompt].count;
            });
            
            const sortedPrompts = matchedPrompts.sort((a, b) => promptCounts[b] - promptCounts[a]);
            
            return `
                <div style="margin-bottom: 20px;">
                    <div style="font-size: 1.1em; margin-bottom: 15px;">
                        <strong>${yoloworldData.length}</strong> detections from 
                        <strong>${matchedPrompts.length}</strong> custom prompts
                    </div>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 15px;">
                        ${sortedPrompts.map(prompt => {
                            const category = promptCategories[prompt].category;
                            const count = promptCounts[prompt];
                            const avgConf = (promptCategories[prompt].avgConfidence * 100).toFixed(1);
                            
                            const categoryColor = 
                                category === 'weapon' ? '#ff0000' :
                                category === 'violence' ? '#ff4444' :
                                category === 'substance' ? '#ff8800' :
                                category === 'person' ? '#00aaff' :
                                'var(--primary)';
                            
                            return `
                                <div style="background: var(--black); padding: 15px; border: 1px solid var(--gray-medium); border-radius: 4px;">
                                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                                        <div style="width: 8px; height: 8px; border-radius: 50%; background: ${categoryColor}; margin-right: 10px;"></div>
                                        <div style="font-weight: 500; color: var(--white); flex: 1;">${prompt}</div>
                                    </div>
                                    <div style="font-size: 0.9em; color: var(--gray-light);">
                                        ${count} detection${count > 1 ? 's' : ''} • ${avgConf}% confidence
                                    </div>
                                    <div style="font-size: 0.85em; color: ${categoryColor}; margin-top: 4px;">
                                        ${category.toUpperCase()}
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            `;
        }
        
        function generateViolenceOutput(segments) {
            if (!segments || segments.length === 0) {
                return '<p style="color: var(--gray-light);">No violence detected in video segments</p>';
            }
            
            const highViolence = segments.filter(s => s.violence_score > 0.7);
            const moderateViolence = segments.filter(s => s.violence_score >= 0.4 && s.violence_score < 0.7);
            const lowViolence = segments.filter(s => s.violence_score < 0.4);
            const maxScore = Math.max(...segments.map(s => s.violence_score), 0);
            const avgScore = segments.reduce((sum, s) => sum + s.violence_score, 0) / segments.length;
            
            return `
                <div style="margin-bottom: 15px;">
                    <strong>Violence Analysis:</strong><br>
                    <div style="background: var(--black); padding: 15px; margin-top: 10px;">
                        <div style="display: grid; grid-template-columns: 150px 1fr; gap: 8px; margin-bottom: 15px;">
                            <div style="color: var(--gray-light);">Segments Analyzed:</div>
                            <div>${segments.length}</div>
                            
                            <div style="color: var(--gray-light);">🔴 High (>70%):</div>
                            <div style="color: ${highViolence.length > 0 ? '#ff4444' : 'inherit'};">${highViolence.length}</div>
                            
                            <div style="color: var(--gray-light);">🟡 Moderate (40-70%):</div>
                            <div style="color: ${moderateViolence.length > 0 ? '#ffaa00' : 'inherit'};">${moderateViolence.length}</div>
                            
                            <div style="color: var(--gray-light);">🟢 Low (<40%):</div>
                            <div>${lowViolence.length}</div>
                            
                            <div style="color: var(--gray-light);">Peak Score:</div>
                            <div>${(maxScore * 100).toFixed(1)}%</div>
                            
                            <div style="color: var(--gray-light);">Average Score:</div>
                            <div>${(avgScore * 100).toFixed(1)}%</div>
                        </div>
                        
                        <strong style="display: block; margin-top: 10px; margin-bottom: 8px;">Top Segments:</strong>
                        <div style="max-height: 200px; overflow-y: auto;">
                            ${segments
                                .sort((a, b) => b.violence_score - a.violence_score)
                                .slice(0, 10)
                                .map((seg, i) => {
                                    const score = seg.violence_score * 100;
                                    const color = score > 70 ? '#ff4444' : score > 40 ? '#ffaa00' : 'inherit';
                                    const timestamp = seg.start_time !== undefined ? 
                                        `${seg.start_time.toFixed(1)}s - ${seg.end_time.toFixed(1)}s` : 
                                        (seg.timestamp !== undefined ? `${seg.timestamp.toFixed(1)}s` : 'N/A');
                                    return `<div style="padding: 8px; border-bottom: 1px solid var(--gray-dark); display: flex; justify-content: space-between;">
                                        <span>${timestamp}</span>
                                        <span style="color: ${color}; font-weight: bold;">${score.toFixed(1)}%</span>
                                    </div>`;
                                }).join('')}
                        </div>
                    </div>
                </div>
            `;
        }
        
        function generateOcrOutput(ocrData) {
            if (!ocrData || ocrData.length === 0) {
                return '<p style="color: var(--gray-light);">No text detected in video frames</p>';
            }
            
            const totalChars = ocrData.reduce((sum, item) => sum + (item.text?.length || 0), 0);
            const avgConfidence = ocrData.reduce((sum, item) => sum + (item.confidence || 0), 0) / ocrData.length;
            
            return `
                <div style="margin-bottom: 15px;">
                    <strong>OCR Results:</strong><br>
                    <div style="background: var(--black); padding: 15px; margin-top: 10px;">
                        <div style="display: grid; grid-template-columns: 150px 1fr; gap: 8px; margin-bottom: 15px;">
                            <div style="color: var(--gray-light);">Text Regions:</div>
                            <div>${ocrData.length}</div>
                            
                            <div style="color: var(--gray-light);">Total Characters:</div>
                            <div>${totalChars}</div>
                            
                            <div style="color: var(--gray-light);">Avg Confidence:</div>
                            <div>${(avgConfidence * 100).toFixed(1)}%</div>
                        </div>
                        
                        <strong style="display: block; margin-top: 10px; margin-bottom: 8px;">Detected Text:</strong>
                        <div style="max-height: 250px; overflow-y: auto;">
                            ${ocrData.slice(0, 15).map((item, i) => 
                                `<div style="padding: 8px; border-bottom: 1px solid var(--gray-dark); background: var(--gray-darker); margin-bottom: 5px;">
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                        <span style="color: var(--gray-light); font-size: 0.85em;">Frame ${item.frame_index || i} @ ${item.timestamp?.toFixed(1) || 'N/A'}s</span>
                                        <span style="font-size: 0.85em; color: ${item.confidence > 0.8 ? '#00aa00' : item.confidence > 0.5 ? '#ffaa00' : 'inherit'};">
                                            ${(item.confidence * 100).toFixed(0)}% confidence
                                        </span>
                                    </div>
                                    <div style="font-family: monospace;">"${item.text || 'N/A'}"</div>
                                </div>`
                            ).join('')}
                        </div>
                    </div>
                </div>
            `;
        }
        
        function generateReportOutput(report) {
            if (!report) {
                return '<div style="text-align: center; color: var(--gray-light); padding: 20px;">No AI report available</div>';
            }
            
            return `
                <div style="margin-bottom: 15px;">
                    <div style="background: var(--black); padding: 20px; margin-top: 10px; line-height: 1.8;">
                        ${marked.parse(report)}
                    </div>
                </div>
            `;
        }
        
        function generateModerationOutput(moderationData) {
            if (!moderationData || moderationData.length === 0) {
                return '<p style="color: var(--gray-light);">No transcript content moderated</p>';
            }
            
            const flagged = moderationData.filter(m => 
                m.profanity_score > 0.3 || m.sexual_score > 0.3 || m.hate_score > 0.3 || m.drugs_score > 0.3 || m.violence_score > 0.3 || m.hate_speech > 0.3
            );
            
            return `
                <div style="margin-bottom: 15px;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-bottom: 20px;">
                        <div style="background: var(--gray-dark); padding: 15px; border-left: 3px solid var(--white);">
                            <div style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 5px;">CHUNKS ANALYZED</div>
                            <div style="font-size: 1.8em; font-weight: 500;">${moderationData.length}</div>
                        </div>
                        <div style="background: var(--gray-dark); padding: 15px; border-left: 3px solid ${flagged.length > 0 ? '#ff0000' : '#00aa00'};">
                            <div style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 5px;">FLAGGED CONTENT</div>
                            <div style="font-size: 1.8em; font-weight: 500; color: ${flagged.length > 0 ? '#ff0000' : '#00aa00'};">${flagged.length}</div>
                        </div>
                    </div>
                    
                    ${flagged.length > 0 ? `
                        <div style="font-size: 0.9em; font-weight: 500; margin-bottom: 12px; letter-spacing: 1px;">FLAGGED TRANSCRIPT SEGMENTS</div>
                        <div style="max-height: 400px; overflow-y: auto;">
                            ${flagged.slice(0, 10).map((item, i) => {
                                const maxScore = Math.max(
                                    item.profanity_score || 0,
                                    item.sexual_score || 0,
                                    item.hate_score || 0,
                                    item.drugs_score || 0,
                                    item.violence_score || 0,
                                    item.hate_speech || 0
                                );
                                const severity = maxScore >= 0.7 ? 'HIGH' : maxScore >= 0.4 ? 'MODERATE' : 'LOW';
                                const severityColor = maxScore >= 0.7 ? '#ff0000' : maxScore >= 0.4 ? '#ffaa00' : '#ffcc00';
                                
                                return `
                                    <div style="background: var(--black); padding: 15px; margin-bottom: 12px; border-left: 3px solid ${severityColor};">
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                                            <strong style="color: var(--white);">Chunk ${i + 1}</strong>
                                            <span style="background: ${severityColor}; color: var(--black); padding: 2px 8px; font-size: 0.75em; font-weight: 600; border-radius: 2px;">${severity}</span>
                                        </div>
                                        
                                        ${item.text ? `
                                            <div style="color: var(--gray-light); font-style: italic; margin-bottom: 12px; padding: 10px; background: var(--gray-dark); border-radius: 2px;">
                                                "${item.text.substring(0, 150)}${item.text.length > 150 ? '...' : ''}"
                                            </div>
                                        ` : ''}
                                        
                                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 10px; font-size: 0.85em;">
                                            ${item.profanity_score > 0.01 ? `
                                                <div>
                                                    <span style="color: var(--gray-light);">Profanity:</span>
                                                    <strong style="color: ${item.profanity_score >= 0.5 ? '#ff0000' : '#ffaa00'};">${(item.profanity_score * 100).toFixed(0)}%</strong>
                                                </div>
                                            ` : ''}
                                            ${item.sexual_score > 0.01 ? `
                                                <div>
                                                    <span style="color: var(--gray-light);">Sexual:</span>
                                                    <strong style="color: ${item.sexual_score >= 0.5 ? '#ff0000' : '#ffaa00'};">${(item.sexual_score * 100).toFixed(0)}%</strong>
                                                </div>
                                            ` : ''}
                                            ${item.hate_score > 0.01 ? `
                                                <div>
                                                    <span style="color: var(--gray-light);">Hate:</span>
                                                    <strong style="color: ${item.hate_score >= 0.5 ? '#ff0000' : '#ffaa00'};">${(item.hate_score * 100).toFixed(0)}%</strong>
                                                </div>
                                            ` : ''}
                                            ${item.drugs_score > 0.01 ? `
                                                <div>
                                                    <span style="color: var(--gray-light);">Drugs:</span>
                                                    <strong style="color: ${item.drugs_score >= 0.5 ? '#ff0000' : '#ffaa00'};">${(item.drugs_score * 100).toFixed(0)}%</strong>
                                                </div>
                                            ` : ''}
                                            ${item.violence_score > 0.01 ? `
                                                <div>
                                                    <span style="color: var(--gray-light);">Violence:</span>
                                                    <strong style="color: ${item.violence_score >= 0.5 ? '#ff0000' : '#ffaa00'};">${(item.violence_score * 100).toFixed(0)}%</strong>
                                                </div>
                                            ` : ''}
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                        ${flagged.length > 10 ? `
                            <div style="text-align: center; padding: 15px; color: var(--gray-light); font-size: 0.9em;">
                                Showing first 10 of ${flagged.length} flagged segments
                            </div>
                        ` : ''}
                    ` : `
                        <div style="text-align: center; padding: 40px; color: var(--gray-light);">
                            <div style="font-size: 2em; margin-bottom: 10px;">✓</div>
                            <div>No problematic content detected in transcript</div>
                        </div>
                    `}
                </div>
            `;
        }
        
        function generateScoringOutput(scores) {
            // Handle both .scores and .criteria formats
            const scoreData = scores || {};
            
            if (Object.keys(scoreData).length === 0) {
                return '<p style="color: var(--gray-light);">No scoring data available</p>';
            }
            
            return `
                <div style="margin-bottom: 15px;">
                    <strong>Criterion Scores:</strong><br>
                    <div style="margin-top: 15px;">
                        ${Object.entries(scoreData).map(([criterion, scoreValue]) => {
                            // Handle both simple number and object with score property
                            const score = typeof scoreValue === 'object' ? scoreValue.score : scoreValue;
                            const scorePercent = (score * 100).toFixed(1);
                            const color = score >= 0.6 ? '#ff0000' : score >= 0.3 ? '#ffaa00' : '#00aa00';
                            
                            return `
                                <div style="padding: 12px 0; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--gray-medium);">
                                    <span style="text-transform: uppercase; letter-spacing: 1px;">${criterion}</span>
                                    <div style="display: flex; align-items: center; gap: 15px;">
                                        <div style="width: 100px; height: 8px; background: var(--gray-dark); border-radius: 4px; overflow: hidden;">
                                            <div style="width: ${scorePercent}%; height: 100%; background: ${color}; transition: width 0.3s;"></div>
                                        </div>
                                        <strong style="color: ${color}; min-width: 50px; text-align: right;">${scorePercent}%</strong>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                    <div style="margin-top: 20px; padding: 15px; background: var(--gray-dark); border-left: 3px solid var(--white);">
                        <div style="font-size: 0.85em; color: var(--gray-light);">
                            <strong>Score Interpretation:</strong><br>
                            <span style="color: #00aa00;">■</span> 0-30%: Low risk<br>
                            <span style="color: #ffaa00;">■</span> 30-60%: Moderate risk<br>
                            <span style="color: #ff0000;">■</span> 60-100%: High risk
                        </div>
                    </div>
                </div>
            `;
        }
        
        function getVerdictColor(verdict) {
            const colors = {
                'SAFE': '#00aa00',
                'CAUTION': '#ffaa00',
                'UNSAFE': '#ff0000',
                'NEEDS_REVIEW': '#00aaff'
            };
            return colors[verdict] || '#ffffff';
        }
        
        // Data Source Selection Functions
        function closeDataSourceModal() {
            document.getElementById('dataSourceModal').style.display = 'none';
        }
        
        function selectDataSource(source) {
            closeDataSourceModal();
            
            switch(source) {
                case 'local':
                    // Trigger file input for local files
                    batchFileInput.click();
                    break;
                case 'storage':
                    // Show storage configuration modal
                    document.getElementById('storageConfigModal').style.display = 'flex';
                    break;
                case 'database':
                    // Show database configuration modal
                    document.getElementById('databaseConfigModal').style.display = 'flex';
                    break;
                case 'url':
                    // Show URL input modal
                    document.getElementById('urlConfigModal').style.display = 'flex';
                    break;
            }
        }
        
        function closeStorageConfigModal() {
            document.getElementById('storageConfigModal').style.display = 'none';
        }
        
        function closeDatabaseConfigModal() {
            document.getElementById('databaseConfigModal').style.display = 'none';
        }
        
        function closeUrlConfigModal() {
            document.getElementById('urlConfigModal').style.display = 'none';
        }
        
        async function fetchFromStorage() {
            const provider = document.getElementById('storageProvider').value;
            const bucket = document.getElementById('storageBucket').value;
            const path = document.getElementById('storagePath').value;
            const credentials = document.getElementById('storageCredentials').value;
            
            if (!bucket) {
                alert('Please enter bucket/container name');
                return;
            }
            
            try {
                const response = await fetch(`${API_URL}/import/storage`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        provider,
                        bucket,
                        path,
                        credentials
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to fetch from storage');
                }
                
                const result = await response.json();
                console.log('Storage import result:', result);
                
                // Add videos to queue
                if (result.videos && result.videos.length > 0) {
                    for (const videoInfo of result.videos) {
                        addVideoToQueue(null, videoInfo.filename, videoInfo.video_id, videoInfo.source);
                    }
                    alert(`Successfully imported ${result.videos.length} video(s) from ${provider}`);
                } else {
                    alert('No videos found in the specified location');
                }
                
                closeStorageConfigModal();
            } catch (error) {
                console.error('Error fetching from storage:', error);
                alert('Error importing from storage: ' + error.message);
            }
        }
        
        async function fetchFromDatabase() {
            const dbType = document.getElementById('databaseType').value;
            const connection = document.getElementById('databaseConnection').value;
            const query = document.getElementById('databaseQuery').value;
            
            if (!connection || !query) {
                alert('Please provide connection string and query');
                return;
            }
            
            try {
                const response = await fetch(`${API_URL}/import/database`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        database_type: dbType,
                        connection_string: connection,
                        query: query
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to fetch from database');
                }
                
                const result = await response.json();
                console.log('Database import result:', result);
                
                // Add videos to queue
                if (result.videos && result.videos.length > 0) {
                    for (const videoInfo of result.videos) {
                        addVideoToQueue(null, videoInfo.filename, videoInfo.video_id, videoInfo.source);
                    }
                    alert(`Successfully imported ${result.videos.length} video(s) from database`);
                } else {
                    alert('No videos found with the specified query');
                }
                
                closeDatabaseConfigModal();
            } catch (error) {
                console.error('Error fetching from database:', error);
                alert('Error importing from database: ' + error.message);
            }
        }
        
        async function fetchFromUrls() {
            const urls = document.getElementById('videoUrls').value;
            
            if (!urls.trim()) {
                alert('Please enter at least one URL');
                return;
            }
            
            const urlList = urls.split('\n')
                .map(url => url.trim())
                .filter(url => url.length > 0);
            
            if (urlList.length === 0) {
                alert('Please enter valid URLs');
                return;
            }
            
            try {
                const response = await fetch(`${API_URL}/import/urls`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        urls: urlList
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to import from URLs');
                }
                
                const result = await response.json();
                console.log('URL import result:', result);
                
                // Add videos to queue
                if (result.videos && result.videos.length > 0) {
                    for (const videoInfo of result.videos) {
                        addVideoToQueue(null, videoInfo.filename, videoInfo.video_id, videoInfo.source);
                    }
                    alert(`Successfully imported ${result.videos.length} video(s) from URLs`);
                } else {
                    alert('Failed to import videos from URLs');
                }
                
                closeUrlConfigModal();
                // Clear the textarea
                document.getElementById('videoUrls').value = '';
            } catch (error) {
                console.error('Error fetching from URLs:', error);
                alert('Error importing from URLs: ' + error.message);
            }
        }
        
        // Helper function to add video to queue with source information
        function addVideoToQueue(file, filename, videoId, source = 'local') {
            const video = {
                id: videoId || `vid_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                filename: filename,
                file: file,
                status: 'queued',
                progress: 0,
                currentStage: null,
                verdict: null,
                result: null,
                batchVideoId: null,
                source: source  // 'local', 'storage', 'database', 'url'
            };
            
            videoQueue.push(video);
            renderVideoTable();
            
            // Enable process button if queue has videos
            if (videoQueue.length > 0) {
                document.getElementById('processAllBtn').disabled = false;
            }
        }
        
        // ============================================
        // POLICY CONFIGURATION FUNCTIONS
        // ============================================
        
        let currentPolicy = null;  // Store current policy config
        
        // Update threshold display value
        function updateThresholdDisplay(threshold, value) {
            const displayEl = document.getElementById(threshold + 'Value');
            if (displayEl) {
                displayEl.textContent = parseFloat(value).toFixed(2);
            }
            // Mark as custom when manually adjusting
            const presetSelect = document.getElementById('policyPresetTab');
            if (presetSelect && presetSelect.value !== 'custom') {
                presetSelect.value = 'custom';
            }
        }
        
        // Load policy presets from backend
        async function loadPolicyPresets() {
            try {
                const response = await fetch(`${API_URL}/policy/presets`);
                if (response.ok) {
                    const data = await response.json();
                    return data.presets;
                }
            } catch (error) {
                console.error('Error loading policy presets:', error);
            }
            return null;
        }
        
        // Load current policy from backend
        async function loadCurrentPolicy() {
            try {
                const response = await fetch(`${API_URL}/policy/current`);
                if (response.ok) {
                    const data = await response.json();
                    currentPolicy = data.policy;
                    return currentPolicy;
                }
            } catch (error) {
                console.error('Error loading current policy:', error);
            }
            return null;
        }
        
        // Close policy modal
        function closePolicyModal() {
            document.getElementById('policySettingsModal').style.display = 'none';
        }
        
        // Populate form with policy values (for tab UI)
        function populatePolicyFormTab(thresholds) {
            if (thresholds.unsafe) {
                document.getElementById('unsafeViolenceTab').value = thresholds.unsafe.violence || 0.75;
                document.getElementById('unsafeSexualTab').value = thresholds.unsafe.sexual || 0.60;
                document.getElementById('unsafeHateTab').value = thresholds.unsafe.hate || 0.60;
                document.getElementById('unsafeDrugsTab').value = thresholds.unsafe.drugs || 0.70;
                
                // Update displays
                updateThresholdDisplay('unsafeViolence', thresholds.unsafe.violence || 0.75);
                updateThresholdDisplay('unsafeSexual', thresholds.unsafe.sexual || 0.60);
                updateThresholdDisplay('unsafeHate', thresholds.unsafe.hate || 0.60);
                updateThresholdDisplay('unsafeDrugs', thresholds.unsafe.drugs || 0.70);
            }
            if (thresholds.caution) {
                document.getElementById('cautionViolenceTab').value = thresholds.caution.violence || 0.40;
                document.getElementById('cautionProfanityTab').value = thresholds.caution.profanity || 0.40;
                document.getElementById('cautionDrugsTab').value = thresholds.caution.drugs || 0.40;
                document.getElementById('cautionSexualTab').value = thresholds.caution.sexual || 0.30;
                document.getElementById('cautionHateTab').value = thresholds.caution.hate || 0.30;
                
                // Update displays
                updateThresholdDisplay('cautionViolence', thresholds.caution.violence || 0.40);
                updateThresholdDisplay('cautionProfanity', thresholds.caution.profanity || 0.40);
                updateThresholdDisplay('cautionDrugs', thresholds.caution.drugs || 0.40);
                updateThresholdDisplay('cautionSexual', thresholds.caution.sexual || 0.30);
                updateThresholdDisplay('cautionHate', thresholds.caution.hate || 0.30);
            }
        }
        
        // Load policy preset
        async function loadPolicyPreset(presetName) {
            const presets = await loadPolicyPresets();
            if (presets && presets[presetName]) {
                const preset = presets[presetName];
                if (preset.thresholds) {
                    populatePolicyFormTab(preset.thresholds);
                }
            }
        }
        
        // Reset policy to default
        async function resetPolicyToDefault() {
            document.getElementById('policyPresetTab').value = 'balanced';
            await loadPolicyPreset('balanced');
        }
        
        // Save policy settings
        async function savePolicySettings() {
            const policyConfig = {
                thresholds: {
                    unsafe: {
                        violence: parseFloat(document.getElementById('unsafeViolenceTab').value),
                        sexual: parseFloat(document.getElementById('unsafeSexualTab').value),
                        hate: parseFloat(document.getElementById('unsafeHateTab').value),
                        drugs: parseFloat(document.getElementById('unsafeDrugsTab').value),
                    },
                    caution: {
                        violence: parseFloat(document.getElementById('cautionViolenceTab').value),
                        profanity: parseFloat(document.getElementById('cautionProfanityTab').value),
                        drugs: parseFloat(document.getElementById('cautionDrugsTab').value),
                        sexual: parseFloat(document.getElementById('cautionSexualTab').value),
                        hate: parseFloat(document.getElementById('cautionHateTab').value),
                    }
                }
            };
            
            // Validate policy
            try {
                const response = await fetch(`${API_URL}/policy/validate`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(policyConfig)
                });
                const result = await response.json();
                
                if (result.valid) {
                    currentPolicy = policyConfig;
                    alert('✅ Policy updated! It will be applied to all new videos.');
                } else {
                    alert('❌ Invalid policy: ' + result.message);
                }
            } catch (error) {
                console.error('Error validating policy:', error);
                alert('❌ Error validating policy');
            }
        }
        
        // ============================================
        // LIVE FEED FUNCTIONS
        // ============================================
        
        let liveStream = null;
        let liveCanvas = null;
        let liveContext = null;
        let liveContextTab = null;  // Canvas context for live feed tab
        let liveAnalysisInterval = null;
        let framesAnalyzedCount = 0;
        let framesAnalyzedCountTab = 0;  // Frame counter for tab
        let liveEvents = [];  // Store live events for the tab
        let currentEventId = null;  // For event viewer
        
        // Load live events from storage
        function loadLiveEvents() {
            const saved = localStorage.getItem('liveEvents');
            if (saved) {
                try {
                    liveEvents = JSON.parse(saved);
                    console.log(`Loaded ${liveEvents.length} live events from storage`);
                    
                    // Auto-cleanup if too many events (keep only 100 most recent)
                    if (liveEvents.length > 100) {
                        console.warn(`Too many events (${liveEvents.length}). Keeping only 100 most recent.`);
                        liveEvents = liveEvents.slice(0, 100);
                        saveLiveEventsToStorage(); // Save cleaned up list
                    }
                } catch (e) {
                    console.error('Failed to load live events:', e);
                    liveEvents = [];
                }
            }
        }
        
        // Save live events to storage
        function saveLiveEventsToStorage() {
            try {
                localStorage.setItem('liveEvents', JSON.stringify(liveEvents));
            } catch (e) {
                if (e.name === 'QuotaExceededError') {
                    console.warn('localStorage quota exceeded. Auto-cleaning old events...');
                    
                    // Remove oldest 50% of events and try again
                    const halfLength = Math.floor(liveEvents.length / 2);
                    liveEvents = liveEvents.slice(0, halfLength);
                    
                    try {
                        localStorage.setItem('liveEvents', JSON.stringify(liveEvents));
                        console.log(`Reduced to ${liveEvents.length} events and saved successfully`);
                    } catch (retryError) {
                        // If still failing, clear all events
                        console.error('Still exceeding quota. Clearing all live events.');
                        liveEvents = [];
                        try {
                            localStorage.setItem('liveEvents', JSON.stringify(liveEvents));
                        } catch (finalError) {
                            console.error('Cannot save even empty array. localStorage may be corrupted.');
                        }
                    }
                } else {
                    console.error('Failed to save live events:', e);
                }
            }
        }
        
        // Update live stats
        function updateLiveStats() {
            const totalEvents = liveEvents.length;
            const violations = liveEvents.filter(e => e.violence_score >= 0.4 || e.objects.some(o => o.category === 'weapon')).length;
            const safe = liveEvents.filter(e => e.violence_score < 0.4 && !e.objects.some(o => o.category === 'weapon')).length;
            const avgViolence = totalEvents > 0 
                ? Math.round((liveEvents.reduce((sum, e) => sum + e.violence_score, 0) / totalEvents) * 100)
                : 0;
            
            // Update stats display
            const statsTotal = document.getElementById('liveStatsTotal');
            const statsViolations = document.getElementById('liveStatsViolations');
            const statsSafe = document.getElementById('liveStatsSafe');
            const statsAvgViolence = document.getElementById('liveStatsAvgViolence');
            
            if (statsTotal) statsTotal.textContent = totalEvents;
            if (statsViolations) statsViolations.textContent = violations;
            if (statsSafe) statsSafe.textContent = safe;
            if (statsAvgViolence) statsAvgViolence.textContent = `${avgViolence}%`;
        }
        
        // Render live events table
        function renderLiveEventsTable() {
            const tbody = document.getElementById('liveEventsTableBody');
            if (!tbody) return;
            
            // Apply filters
            const filter = document.getElementById('liveEventsFilter')?.value || 'all';
            const streamFilter = document.getElementById('liveEventsStream')?.value || 'all';
            
            let filtered = liveEvents.filter(event => {
                // Stream filter
                if (streamFilter !== 'all' && event.stream_id !== streamFilter) return false;
                
                // Severity filter
                if (filter === 'violations' && event.violence_score < 0.4) return false;
                if (filter === 'high-violence' && event.violence_score < 0.7) return false;
                if (filter === 'weapons' && !event.objects.some(o => o.category === 'weapon')) return false;
                if (filter === 'safe' && event.violence_score >= 0.4) return false;
                
                return true;
            });
            
            // Sort by timestamp (newest first)
            filtered.sort((a, b) => b.timestamp - a.timestamp);
            
            // Update count
            document.getElementById('liveEventsCount').textContent = `${filtered.length} events`;
            
            // Update stats
            updateLiveStats();
            
            // Render table
            if (filtered.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="7" style="text-align: center; padding: 40px; color: var(--gray-light);">
                            <div style="font-size: 1.2em; margin-bottom: 10px;">No events match your filters</div>
                            <div style="font-size: 0.9em;">Try adjusting the filters or start a live feed</div>
                        </td>
                    </tr>
                `;
                return;
            }
            
            tbody.innerHTML = filtered.map((event, index) => {
                const violencePercent = Math.round(event.violence_score * 100);
                const time = new Date(event.timestamp).toLocaleTimeString();
                const status = event.reviewed ? (event.manual_verdict || 'REVIEWED') : (violencePercent > 40 ? 'VIOLATION' : 'SAFE');
                const statusColor = status === 'SAFE' ? '#00aa00' : '#ff0000';
                
                return `
                    <tr data-event-id="${event.frame_id}">
                        <td style="cursor: pointer;" onclick="viewLiveEvent('${event.frame_id}')">
                            <div style="width: 80px; height: 60px; background: #000; border-radius: 4px; overflow: hidden;">
                                ${event.thumbnail ? `<img src="${event.thumbnail}" style="width: 100%; height: 100%; object-fit: cover;">` : '<div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: var(--gray-light);">No thumb</div>'}
                            </div>
                        </td>
                        <td style="cursor: pointer;" onclick="viewLiveEvent('${event.frame_id}')">${time}</td>
                        <td style="cursor: pointer;" onclick="viewLiveEvent('${event.frame_id}')">${event.stream_id}</td>
                        <td style="cursor: pointer;" onclick="viewLiveEvent('${event.frame_id}')">
                            <span style="color: ${violencePercent > 70 ? '#ff0000' : violencePercent > 40 ? '#ffaa00' : '#00aa00'};">
                                ${violencePercent}%
                            </span>
                        </td>
                        <td style="cursor: pointer;" onclick="viewLiveEvent('${event.frame_id}')">${event.objects.length}</td>
                        <td style="cursor: pointer;" onclick="viewLiveEvent('${event.frame_id}')">
                            <span style="background: ${statusColor}33; color: ${statusColor}; padding: 4px 8px; border-radius: 4px; font-size: 0.8em;">
                                ${status}
                            </span>
                        </td>
                        <td style="text-align: center;">
                            <button class="icon-btn" onclick="viewLiveEvent('${event.frame_id}')" title="View Details">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                    <circle cx="12" cy="12" r="3"></circle>
                                </svg>
                            </button>
                            <button class="icon-btn" onclick="deleteLiveEvent('${event.frame_id}')" title="Delete" style="color: #ff0000;">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="3 6 5 6 21 6"></polyline>
                                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                </svg>
                            </button>
                        </td>
                    </tr>
                `;
            }).join('');
            
            // Update stats
            updateLiveEventsStats();
        }
        
        // Update live events stats
        function updateLiveEventsStats() {
            const total = liveEvents.length;
            const violations = liveEvents.filter(e => e.violence_score >= 0.4).length;
            const safe = total - violations;
            const avgViolence = total > 0 
                ? liveEvents.reduce((sum, e) => sum + e.violence_score, 0) / total 
                : 0;
            
            document.getElementById('totalLiveEvents').textContent = total;
            document.getElementById('totalViolations').textContent = violations;
            document.getElementById('totalSafe').textContent = safe;
            document.getElementById('avgViolenceScore').textContent = `${Math.round(avgViolence * 100)}%`;
            
            // Update stream filter options
            const streamFilter = document.getElementById('liveEventsStream');
            if (streamFilter) {
                const streams = [...new Set(liveEvents.map(e => e.stream_id))];
                const currentValue = streamFilter.value;
                streamFilter.innerHTML = '<option value="all">All Streams</option>' + 
                    streams.map(s => `<option value="${s}">${s}</option>`).join('');
                streamFilter.value = currentValue;
            }
        }
        
        // Filter live events
        function filterLiveEvents() {
            renderLiveEventsTable();
        }
        
        // Refresh live events
        function refreshLiveEvents() {
            renderLiveEventsTable();
        }
        
        // Clear live events
        function clearLiveEvents() {
            if (confirm('Are you sure you want to clear all live events? This cannot be undone.')) {
                liveEvents = [];
                saveLiveEventsToStorage();
                renderLiveEventsTable();
            }
        }
        
        // View live event details
        function viewLiveEvent(frameId) {
            const event = liveEvents.find(e => e.frame_id === frameId);
            if (!event) {
                console.error('Event not found:', frameId);
                return;
            }
            
            currentEventId = frameId;
            
            // Show modal
            const modal = document.getElementById('liveEventViewerModal');
            modal.style.display = 'flex';
            modal.style.position = 'fixed';
            modal.style.zIndex = '10000';
            document.body.style.overflow = 'hidden';
            
            console.log('Opening event viewer for:', frameId);
            
            // Load frame image
            const img = document.getElementById('eventFrameImage');
            img.src = event.thumbnail || '';
            
            // Draw detections on canvas
            img.onload = () => {
                const canvas = document.getElementById('eventDetectionCanvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                
                // Clear
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw bounding boxes
                event.objects.forEach(obj => {
                    const bbox = obj.bbox;
                    const category = obj.category || 'other';
                    
                    let color;
                    if (category === 'weapon') color = '#FF0000';
                    else if (category === 'substance') color = '#FFA500';
                    else if (category === 'person') color = '#00FFFF';
                    else color = '#00FF00';
                    
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 3;
                    ctx.strokeRect(bbox.x1, bbox.y1, bbox.x2 - bbox.x1, bbox.y2 - bbox.y1);
                    
                    // Label
                    const labelText = `${obj.label} ${Math.round(obj.confidence * 100)}%`;
                    ctx.font = '14px Arial';
                    const textWidth = ctx.measureText(labelText).width;
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(bbox.x1, bbox.y1 - 20, textWidth + 10, 20);
                    ctx.fillStyle = '#000';
                    ctx.fillText(labelText, bbox.x1 + 5, bbox.y1 - 5);
                });
            };
            
            // Populate details
            const violencePercent = Math.round(event.violence_score * 100);
            const time = new Date(event.timestamp).toLocaleString();
            
            document.getElementById('eventDetails').innerHTML = `
                <div style="margin-bottom: 15px;">
                    <div style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 3px;">EVENT ID</div>
                    <div style="font-family: monospace;">${event.frame_id.slice(0, 12)}...</div>
                </div>
                <div style="margin-bottom: 15px;">
                    <div style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 3px;">TIMESTAMP</div>
                    <div>${time}</div>
                </div>
                <div style="margin-bottom: 15px;">
                    <div style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 3px;">STREAM</div>
                    <div>${event.stream_id}</div>
                </div>
                <div style="margin-bottom: 15px;">
                    <div style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 3px;">VIOLENCE SCORE</div>
                    <div style="font-size: 1.5em; color: ${violencePercent > 70 ? '#ff0000' : violencePercent > 40 ? '#ffaa00' : '#00aa00'};">
                        ${violencePercent}%
                    </div>
                </div>
                <div style="margin-bottom: 15px;">
                    <div style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 5px;">OBJECTS DETECTED</div>
                    <div style="display: flex; flex-wrap: wrap; gap: 5px;">
                        ${event.objects.map(o => `
                            <span style="background: var(--gray-dark); padding: 4px 8px; border-radius: 4px; font-size: 0.85em;">
                                ${o.label} (${Math.round(o.confidence * 100)}%)
                            </span>
                        `).join('')}
                    </div>
                </div>
                ${event.reviewed ? `
                    <div style="margin-top: 15px; padding: 10px; background: var(--gray-dark); border-radius: 4px;">
                        <div style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 5px;">MANUAL REVIEW</div>
                        <div style="margin-bottom: 5px;">Verdict: <strong>${event.manual_verdict}</strong></div>
                        ${event.notes ? `<div style="color: var(--gray-light);">${event.notes}</div>` : ''}
                    </div>
                ` : ''}
            `;
            
            // Load existing notes
            document.getElementById('eventNotes').value = event.notes || '';
        }
        
        // Close live event viewer
        function closeLiveEventViewer() {
            document.getElementById('liveEventViewerModal').style.display = 'none';
            document.body.style.overflow = '';
            currentEventId = null;
        }
        
        // Mark event as safe/violation
        function markEventAs(verdict) {
            if (!currentEventId) return;
            
            const event = liveEvents.find(e => e.frame_id === currentEventId);
            if (event) {
                event.manual_verdict = verdict.toUpperCase();
                event.reviewed = true;
                saveLiveEventsToStorage();
                renderLiveEventsTable();
            }
        }
        
        // Save event review
        function saveEventReview() {
            if (!currentEventId) return;
            
            const event = liveEvents.find(e => e.frame_id === currentEventId);
            if (event) {
                event.notes = document.getElementById('eventNotes').value;
                event.reviewed = true;
                saveLiveEventsToStorage();
                renderLiveEventsTable();
                
                alert('Review saved successfully!');
                closeLiveEventViewer();
            }
        }
        
        // Delete live event
        function deleteLiveEvent(frameId) {
            if (confirm('Delete this event?')) {
                liveEvents = liveEvents.filter(e => e.frame_id !== frameId);
                saveLiveEventsToStorage();
                renderLiveEventsTable();
            }
        }
        
        // Open live feed modal
        document.getElementById('liveFeedBtn').addEventListener('click', () => {
            document.getElementById('liveFeedModal').style.display = 'flex';
        });
        
        function closeLiveFeedModal() {
            document.getElementById('liveFeedModal').style.display = 'none';
            // Don't call stopLiveFeed() here - causes infinite recursion
            // stopLiveFeed() will call this function when needed
        }
        
        function toggleLiveFeedOptions() {
            const feedType = document.getElementById('liveFeedType').value;
            const webcamOptions = document.getElementById('webcamOptions');
            const streamUrlOptions = document.getElementById('streamUrlOptions');
            
            if (feedType === 'webcam') {
                webcamOptions.style.display = 'block';
                streamUrlOptions.style.display = 'none';
            } else {
                webcamOptions.style.display = 'none';
                streamUrlOptions.style.display = 'block';
            }
        }
        
        function toggleIntervalOptions() {
            const mode = document.getElementById('liveProcessingMode').value;
            const intervalOptions = document.getElementById('intervalOptions');
            
            if (mode === 'interval') {
                intervalOptions.style.display = 'block';
            } else {
                intervalOptions.style.display = 'none';
            }
        }
        
        async function startLiveFeed() {
            // Close modal
            closeLiveFeedModal();
            
            // Copy settings to tab
            document.getElementById('liveFeedTypeTab').value = document.getElementById('liveFeedType').value;
            document.getElementById('cameraDeviceTab').value = document.getElementById('cameraDevice').value;
            document.getElementById('liveProcessingModeTab').value = document.getElementById('liveProcessingMode').value;
            
            // Navigate to Live Feed tab
            document.querySelectorAll('.sidebar-link').forEach(l => l.classList.remove('active'));
            const liveFeedLink = document.querySelector('.sidebar-link[data-tab="live-feed"]');
            if (liveFeedLink) {
                liveFeedLink.classList.add('active');
            }
            
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            const liveFeedTab = document.getElementById('live-feed');
            if (liveFeedTab) {
                liveFeedTab.classList.add('active');
            }
            
            // Start the feed in the tab
            await startLiveFeedTab();
        }
        
        async function startLiveFeedTab() {
            const feedType = document.getElementById('liveFeedTypeTab').value;
            const processingMode = document.getElementById('liveProcessingModeTab').value;
            const livePreviewVideo = document.getElementById('livePreviewVideoTab');
            const liveFeedViewArea = document.getElementById('liveFeedViewArea');
            const liveFeedEmptyState = document.getElementById('liveFeedEmptyState');
            const liveDetectionCanvas = document.getElementById('liveDetectionCanvasTab');
            
            try {
                document.getElementById('liveStatusTextTab').textContent = 'Starting...';
                document.getElementById('liveStatusTextTab').style.color = '#ffaa00';
                
                // Show video area, hide empty state
                liveFeedViewArea.style.display = 'block';
                liveFeedEmptyState.style.display = 'none';
                
                if (feedType === 'webcam') {
                    liveStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                    livePreviewVideo.srcObject = liveStream;
                    
                    // Wait for video to be ready before initializing canvas
                    await new Promise((resolve) => {
                        livePreviewVideo.onloadedmetadata = () => {
                            // Initialize canvas with video dimensions
                            liveDetectionCanvas.width = livePreviewVideo.videoWidth;
                            liveDetectionCanvas.height = livePreviewVideo.videoHeight;
                            liveContextTab = liveDetectionCanvas.getContext('2d');
                            console.log('Canvas initialized:', liveDetectionCanvas.width, 'x', liveDetectionCanvas.height);
                            resolve();
                        };
                    });
                    
                    await livePreviewVideo.play();
                }
                
                // Update UI
                document.getElementById('startLiveFeedTabBtn').style.display = 'none';
                document.getElementById('stopLiveFeedTabBtn').style.display = 'inline-block';
                document.getElementById('liveStatusTextTab').textContent = 'Analyzing...';
                document.getElementById('liveStatusTextTab').style.color = '#00aa00';
                
                // Start analysis
                if (processingMode === 'continuous') {
                    startContinuousAnalysisTab();
                } else if (processingMode === 'interval') {
                    startIntervalAnalysisTab(5000);
                }
                
                console.log('Live feed started in tab view');
            } catch (error) {
                console.error('Error starting live feed:', error);
                alert('Error starting live feed: ' + error.message);
                stopLiveFeedTab();
            }
        }
        
        function stopLiveFeedTab() {
            // Stop stream
            if (liveStream) {
                liveStream.getTracks().forEach(track => track.stop());
                liveStream = null;
            }
            
            // Stop analysis
            if (liveAnalysisInterval) {
                clearInterval(liveAnalysisInterval);
                liveAnalysisInterval = null;
            }
            
            // Clear canvas
            const liveDetectionCanvas = document.getElementById('liveDetectionCanvasTab');
            if (liveDetectionCanvas) {
                const ctx = liveDetectionCanvas.getContext('2d');
                ctx.clearRect(0, 0, liveDetectionCanvas.width, liveDetectionCanvas.height);
            }
            
            // Reset UI
            document.getElementById('livePreviewVideoTab').srcObject = null;
            document.getElementById('livePreviewVideoTab').src = '';
            document.getElementById('liveFeedViewArea').style.display = 'none';
            document.getElementById('liveFeedEmptyState').style.display = 'block';
            document.getElementById('startLiveFeedTabBtn').style.display = 'inline-block';
            document.getElementById('stopLiveFeedTabBtn').style.display = 'none';
            document.getElementById('liveStatusTextTab').textContent = 'Idle';
            document.getElementById('liveStatusTextTab').style.color = '#666';
            framesAnalyzedCount = 0;
            document.getElementById('framesAnalyzedTab').textContent = '0';
            document.getElementById('liveViolenceScoreTab').textContent = '0%';
            document.getElementById('liveObjectCountTab').textContent = '0';
            document.getElementById('liveViolenceScoreTab').style.color = '#00aa00';
            
            // Navigate to Live Events tab
            document.querySelectorAll('.sidebar-link').forEach(l => l.classList.remove('active'));
            const liveEventsLink = document.querySelector('.sidebar-link[data-tab="live-events"]');
            if (liveEventsLink) {
                liveEventsLink.classList.add('active');
            }
            
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            const liveEventsTab = document.getElementById('live-events');
            if (liveEventsTab) {
                liveEventsTab.classList.add('active');
            }
            
            // Refresh events table
            renderLiveEventsTable();
            
            console.log('Live feed stopped. Navigated to Live Events tab.');
        }
        
        async function startContinuousAnalysisTab() {
            liveAnalysisInterval = setInterval(async () => {
                const blob = await captureFrameTab();
                if (blob) {
                    analyzeFrameTab(blob);
                }
            }, 500); // 2 FPS
        }
        
        async function startIntervalAnalysisTab(interval) {
            liveAnalysisInterval = setInterval(async () => {
                const blob = await captureFrameTab();
                if (blob) {
                    analyzeFrameTab(blob);
                }
            }, interval);
        }
        
        async function captureFrameTab() {
            const video = document.getElementById('livePreviewVideoTab');
            if (!video || video.readyState < 2) return null;
            
            if (!liveCanvas) {
                liveCanvas = document.createElement('canvas');
                liveContext = liveCanvas.getContext('2d');
            }
            
            liveCanvas.width = video.videoWidth;
            liveCanvas.height = video.videoHeight;
            liveContext.drawImage(video, 0, 0);
            
            return new Promise((resolve) => {
                liveCanvas.toBlob((blob) => resolve(blob), 'image/jpeg', 0.8);
            });
        }
        
        async function analyzeFrameTab(frameBlob) {
            if (!frameBlob) return;
            
            const formData = new FormData();
            formData.append('frame', frameBlob, 'frame.jpg');
            
            try {
                const response = await fetch(`${API_URL}/live/analyze-frame`, {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error(`Backend analysis failed: ${response.status}`);
                }
                
                const result = await response.json();
                framesAnalyzedCount++;
                document.getElementById('framesAnalyzedTab').textContent = framesAnalyzedCount;
                updateLiveAnalysisUITab(result);
            } catch (error) {
                console.error('Error analyzing frame:', error);
            }
        }
        
        function updateLiveAnalysisUITab(result) {
            // Update violence score
            if (result.violence_score !== undefined) {
                const violencePercent = Math.round(result.violence_score * 100);
                document.getElementById('liveViolenceScoreTab').textContent = `${violencePercent}%`;
                document.getElementById('liveViolenceScoreTab').style.color =
                    violencePercent > 70 ? '#ff0000' :
                    violencePercent > 40 ? '#ffaa00' : '#00aa00';
            }
            
            // Update object count
            if (result.objects !== undefined) {
                document.getElementById('liveObjectCountTab').textContent = result.objects.length || 0;
                
                // Update latest detections list
                updateLatestDetections(result.objects);
                
                // Draw bounding boxes
                drawBoundingBoxesTab(result.objects);
            }
            
            // Update recent events stream
            updateRecentEventsStream(result);
            
            // Save event (existing function)
            const autoSave = document.getElementById('autoSaveEvents')?.checked;
            if (autoSave) {
                saveLiveEvent(result);
            }
        }
        
        function updateLatestDetections(objects) {
            const container = document.getElementById('latestDetections');
            if (!objects || objects.length === 0) {
                container.innerHTML = '<div style="color: var(--gray-light); text-align: center; padding: 20px;">No detections</div>';
                return;
            }
            
            container.innerHTML = objects.slice(0, 5).map(obj => `
                <div style="padding: 8px; margin-bottom: 6px; background: var(--black); border-radius: 4px; border-left: 3px solid ${
                    obj.category === 'weapon' ? '#ff0000' :
                    obj.category === 'person' ? '#00ffff' : '#00ff00'
                };">
                    <div style="font-weight: 600; margin-bottom: 3px;">${obj.label}</div>
                    <div style="font-size: 0.75em; color: var(--gray-light);">
                        Confidence: ${Math.round(obj.confidence * 100)}%
                    </div>
                </div>
            `).join('');
        }
        
        function updateRecentEventsStream(result) {
            const container = document.getElementById('recentEventsStream');
            if (!container) {
                console.error('Recent events stream container not found');
                return;
            }
            if (!result || !result.frame_id) {
                console.warn('No result or frame_id for recent events stream');
                return;
            }
            
            const violencePercent = Math.round((result.violence_score || 0) * 100);
            const statusColor = violencePercent > 40 ? '#ff0000' : '#00aa00';
            const statusText = violencePercent > 40 ? 'VIOLATION' : 'SAFE';
            
            // Create thumbnail from CANVAS (with bounding boxes), not just video
            const video = document.getElementById('livePreviewVideoTab');
            const detectionCanvas = document.getElementById('liveDetectionCanvasTab');
            
            if (!video || !detectionCanvas) {
                console.warn('Video or canvas element not found for thumbnail');
                return;
            }
            
            if (video.readyState < 2 || !video.videoWidth) {
                console.warn('Video not ready for thumbnail capture', {
                    readyState: video.readyState,
                    videoWidth: video.videoWidth
                });
                return;
            }
            
            try {
                // Create a composite canvas with both video and bounding boxes
                const compositeCanvas = document.createElement('canvas');
                compositeCanvas.width = 160;
                compositeCanvas.height = 120;
                const ctx = compositeCanvas.getContext('2d');
                
                // Fill with black background first
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, 160, 120);
                
                // Calculate aspect ratio to fit video
                const videoWidth = video.videoWidth;
                const videoHeight = video.videoHeight;
                const aspectRatio = videoWidth / videoHeight;
                const targetAspectRatio = 160 / 120;
                
                let drawWidth = 160;
                let drawHeight = 120;
                let offsetX = 0;
                let offsetY = 0;
                
                if (aspectRatio > targetAspectRatio) {
                    // Video is wider - fit to width
                    drawHeight = 160 / aspectRatio;
                    offsetY = (120 - drawHeight) / 2;
                } else {
                    // Video is taller - fit to height
                    drawWidth = 120 * aspectRatio;
                    offsetX = (160 - drawWidth) / 2;
                }
                
                // Draw video frame
                ctx.drawImage(video, offsetX, offsetY, drawWidth, drawHeight);
                
                // Draw detection canvas on top (with bounding boxes)
                if (detectionCanvas.width > 0 && detectionCanvas.height > 0) {
                    ctx.drawImage(detectionCanvas, offsetX, offsetY, drawWidth, drawHeight);
                }
                
                const thumbnail = compositeCanvas.toDataURL('image/jpeg', 0.6);
                
                // Verify thumbnail is not completely black
                if (thumbnail.length < 1000) {
                    console.warn('Thumbnail too small, likely blank');
                    return;
                }
                
                // Add to beginning
                const eventCard = document.createElement('div');
                eventCard.style.cssText = 'background: var(--black); border-radius: 4px; overflow: hidden; cursor: pointer; border: 1px solid var(--gray-medium); flex-shrink: 0; width: 160px;';
                eventCard.onclick = () => viewLiveEvent(result.frame_id);
                eventCard.innerHTML = `
                    <img src="${thumbnail}" style="width: 100%; height: 120px; object-fit: cover; display: block;">
                    <div style="padding: 8px;">
                        <div style="font-size: 0.75em; color: ${statusColor}; font-weight: 600; margin-bottom: 3px;">${statusText}</div>
                        <div style="font-size: 0.7em; color: var(--gray-light);">${violencePercent}% | ${result.objects?.length || 0} obj</div>
                    </div>
                `;
                
                // Clear empty state if present
                if (container.children.length === 1 && container.children[0].textContent.includes('No events')) {
                    container.innerHTML = '';
                }
                
                container.insertBefore(eventCard, container.firstChild);
                
                // Keep only last 12 events
                while (container.children.length > 12) {
                    container.removeChild(container.lastChild);
                }
                
                console.log('✅ Added event to recent stream:', result.frame_id, {
                    violence: violencePercent + '%',
                    objects: result.objects?.length || 0,
                    thumbnailSize: Math.round(thumbnail.length / 1024) + 'KB'
                });
            } catch (error) {
                console.error('❌ Error creating event thumbnail:', error);
            }
        }
        
        function drawBoundingBoxesTab(objects) {
            const canvas = document.getElementById('liveDetectionCanvasTab');
            const video = document.getElementById('livePreviewVideoTab');
            
            if (!canvas || !video) {
                console.warn('Canvas or video element not found');
                return;
            }
            
            // Ensure canvas dimensions match video
            if (canvas.width === 0 || canvas.height === 0) {
                canvas.width = video.videoWidth || 640;
                canvas.height = video.videoHeight || 480;
                console.log('Canvas dimensions updated:', canvas.width, 'x', canvas.height);
            }
            
            const ctx = canvas.getContext('2d');
            
            // Clear previous drawings
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!objects || objects.length === 0) {
                return;
            }
            
            // Calculate scale factors
            const scaleX = canvas.width / video.videoWidth;
            const scaleY = canvas.height / video.videoHeight;
            
            console.log(`Drawing ${objects.length} bounding boxes`);
            
            objects.forEach(obj => {
                const bbox = obj.bbox;
                if (!bbox) return;
                
                const x1 = bbox.x1 * scaleX;
                const y1 = bbox.y1 * scaleY;
                const width = (bbox.x2 - bbox.x1) * scaleX;
                const height = (bbox.y2 - bbox.y1) * scaleY;
                
                // Color by category
                let color;
                if (obj.category === 'weapon') color = '#FF0000';      // Red
                else if (obj.category === 'substance') color = '#FFA500'; // Orange
                else if (obj.category === 'person') color = '#00FFFF';   // Cyan
                else color = '#00FF00';                                  // Green
                
                // Draw rectangle
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.strokeRect(x1, y1, width, height);
                
                // Draw label background
                const text = `${obj.label} ${Math.round(obj.confidence * 100)}%`;
                ctx.font = '14px Arial';
                const textWidth = ctx.measureText(text).width;
                ctx.fillStyle = color;
                ctx.fillRect(x1, y1 - 20, textWidth + 10, 20);
                
                // Draw label text
                ctx.fillStyle = '#000'; // Black text for contrast
                ctx.fillText(text, x1 + 5, y1 - 5);
            });
        }
        
        function viewAllLiveEvents() {
            document.querySelectorAll('.sidebar-link').forEach(l => l.classList.remove('active'));
            const liveEventsLink = document.querySelector('.sidebar-link[data-tab="live-events"]');
            if (liveEventsLink) {
                liveEventsLink.classList.add('active');
            }
            
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            const liveEventsTab = document.getElementById('live-events');
            if (liveEventsTab) {
                liveEventsTab.classList.add('active');
            }
            
            renderLiveEventsTable();
        }
        
        // OLD startLiveFeed for modal (deprecated, now just redirects to tab)
        async function startLiveFeedOld() {
            const feedType = document.getElementById('liveFeedType').value;
            const processingMode = document.getElementById('liveProcessingMode').value;
            const livePreviewVideo = document.getElementById('livePreviewVideo');
            const livePreviewArea = document.getElementById('livePreviewArea');
            const liveAnalysisStatus = document.getElementById('liveAnalysisStatus');
            
            try {
                if (feedType === 'webcam') {
                    // Access webcam
                    const cameraDevice = document.getElementById('cameraDevice').value;
                    const constraints = {
                        video: {
                            facingMode: cameraDevice,
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        },
                        audio: false
                    };
                    
                    liveStream = await navigator.mediaDevices.getUserMedia(constraints);
                    livePreviewVideo.srcObject = liveStream;
                    
                } else {
                    // Stream URL (RTSP/RTMP/HLS)
                    const streamUrl = document.getElementById('streamUrl').value;
                    
                    if (!streamUrl) {
                        alert('Please enter a stream URL');
                        return;
                    }
                    
                    // For RTSP/RTMP, we need backend support
                    // For HLS, we can use the video element directly
                    if (feedType === 'http') {
                        livePreviewVideo.src = streamUrl;
                    } else {
                        // Send to backend to handle RTSP/RTMP
                        alert(`${feedType.toUpperCase()} stream support requires backend processing. Starting backend stream...`);
                        // Backend will handle the stream
                        const response = await fetch(`${API_URL}/live/stream/start`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                stream_url: streamUrl,
                                stream_type: feedType
                            })
                        });
                        
                        if (!response.ok) {
                            throw new Error('Failed to start backend stream');
                        }
                        
                        const data = await response.json();
                        // Use backend-provided stream endpoint
                        livePreviewVideo.src = `${API_URL}/live/stream/${data.stream_id}`;
                    }
                }
                
                // Show preview area
                livePreviewArea.style.display = 'block';
                liveAnalysisStatus.style.display = 'block';
                
                // Update UI
                document.getElementById('startLiveFeedBtn').style.display = 'none';
                document.getElementById('stopLiveFeedBtn').style.display = 'inline-block';
                document.getElementById('liveStatusText').textContent = 'Analyzing...';
                
                // Create canvas for frame capture
                liveCanvas = document.createElement('canvas');
                liveContext = liveCanvas.getContext('2d');
                
                // Initialize detection canvas
                const detectionCanvas = document.getElementById('liveDetectionCanvas');
                const video = document.getElementById('livePreviewVideo');
                
                // Update canvas size when video metadata loads
                video.onloadedmetadata = () => {
                    detectionCanvas.width = video.videoWidth;
                    detectionCanvas.height = video.videoHeight;
                };
                
                // Start analysis based on processing mode
                if (processingMode === 'continuous') {
                    startContinuousAnalysis();
                } else if (processingMode === 'interval') {
                    const interval = parseInt(document.getElementById('analysisInterval').value) * 1000;
                    startIntervalAnalysis(interval);
                } else if (processingMode === 'motion') {
                    startMotionTriggeredAnalysis();
                }
                
            } catch (error) {
                console.error('Error starting live feed:', error);
                alert('Error starting live feed: ' + error.message);
                stopLiveFeed();
            }
        }
        
        function stopLiveFeed() {
            // Stop stream
            if (liveStream) {
                liveStream.getTracks().forEach(track => track.stop());
                liveStream = null;
            }
            
            // Stop analysis
            if (liveAnalysisInterval) {
                clearInterval(liveAnalysisInterval);
                liveAnalysisInterval = null;
            }
            
            // Clear detection canvas
            const detectionCanvas = document.getElementById('liveDetectionCanvas');
            if (detectionCanvas) {
                const ctx = detectionCanvas.getContext('2d');
                ctx.clearRect(0, 0, detectionCanvas.width, detectionCanvas.height);
            }
            
            // Reset UI
            document.getElementById('livePreviewVideo').srcObject = null;
            document.getElementById('livePreviewVideo').src = '';
            document.getElementById('livePreviewArea').style.display = 'none';
            document.getElementById('startLiveFeedBtn').style.display = 'inline-block';
            document.getElementById('stopLiveFeedBtn').style.display = 'none';
            document.getElementById('liveStatusText').textContent = 'Idle';
            framesAnalyzedCount = 0;
            document.getElementById('framesAnalyzed').textContent = '0';
            document.getElementById('liveViolenceScore').textContent = '0%';
            document.getElementById('liveObjectCount').textContent = '0';
            
            // Close modal (DON'T call this - causes infinite recursion!)
            // closeLiveFeedModal() will be called separately if needed
            document.getElementById('liveFeedModal').style.display = 'none';
            
            // Switch to Live Events tab
            document.querySelectorAll('.sidebar-link').forEach(l => l.classList.remove('active'));
            const liveEventsLink = document.querySelector('.sidebar-link[data-tab="live-events"]');
            if (liveEventsLink) {
                liveEventsLink.classList.add('active');
            }
            
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            const liveEventsTab = document.getElementById('live-events');
            if (liveEventsTab) {
                liveEventsTab.classList.add('active');
            }
            
            // Refresh the events table
            renderLiveEventsTable();
            
            console.log('Live feed stopped. Navigated to Live Events tab.');
        }
        
        function captureFrame() {
            const video = document.getElementById('livePreviewVideo');
            
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                liveCanvas.width = video.videoWidth;
                liveCanvas.height = video.videoHeight;
                liveContext.drawImage(video, 0, 0);
                
                // Convert canvas to blob
                return new Promise((resolve) => {
                    liveCanvas.toBlob((blob) => {
                        resolve(blob);
                    }, 'image/jpeg', 0.8);
                });
            }
            return null;
        }
        
        async function analyzeFrame(frameBlob) {
            if (!frameBlob) return;
            
            const formData = new FormData();
            formData.append('frame', frameBlob, 'frame.jpg');
            
            try {
                const response = await fetch(`${API_URL}/live/analyze-frame`, {
                    method: 'POST',
                    body: formData
                });
                
                if (response.ok) {
                    const result = await response.json();
                    updateLiveAnalysisUI(result);
                    framesAnalyzedCount++;
                    document.getElementById('framesAnalyzed').textContent = framesAnalyzedCount;
                }
            } catch (error) {
                console.error('Error analyzing frame:', error);
            }
        }
        
        function updateLiveAnalysisUI(result) {
            // Update violence score
            if (result.violence_score !== undefined) {
                const violencePercent = Math.round(result.violence_score * 100);
                document.getElementById('liveViolenceScore').textContent = `${violencePercent}%`;
                document.getElementById('liveViolenceScore').style.color = 
                    violencePercent > 70 ? '#ff0000' : 
                    violencePercent > 40 ? '#ffaa00' : '#00aa00';
            }
            
            // Update object count
            if (result.objects !== undefined) {
                document.getElementById('liveObjectCount').textContent = result.objects.length || 0;
            }
            
            // Draw bounding boxes on canvas
            if (result.objects && result.objects.length > 0) {
                drawBoundingBoxes(result.objects);
            }
            
            // Save to live events if auto-save is enabled
            const autoSave = document.getElementById('autoSaveEvents')?.checked;
            if (autoSave) {
                saveLiveEvent(result);
            }
        }
        
        // Save live event
        function saveLiveEvent(result) {
            // Capture thumbnail from CANVAS (with labels), not just video
            const video = document.getElementById('livePreviewVideoTab') || document.getElementById('livePreviewVideo');
            const detectionCanvas = document.getElementById('liveDetectionCanvasTab') || document.getElementById('liveDetectionCanvas');
            
            if (!video || !detectionCanvas) {
                console.warn('Cannot save event: video or canvas not found');
                return;
            }
            
            if (video.readyState < 2 || !video.videoWidth) {
                console.warn('Cannot save event: video not ready');
                return;
            }
            
            try {
                // Create composite canvas with both video and bounding boxes
                const compositeCanvas = document.createElement('canvas');
                const maxWidth = 160;
                const maxHeight = 120;
                
                compositeCanvas.width = maxWidth;
                compositeCanvas.height = maxHeight;
                const ctx = compositeCanvas.getContext('2d');
                
                // Fill with black background
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, maxWidth, maxHeight);
                
                // Calculate aspect ratio to fit video
                const videoWidth = video.videoWidth;
                const videoHeight = video.videoHeight;
                const aspectRatio = videoWidth / videoHeight;
                const targetAspectRatio = maxWidth / maxHeight;
                
                let drawWidth = maxWidth;
                let drawHeight = maxHeight;
                let offsetX = 0;
                let offsetY = 0;
                
                if (aspectRatio > targetAspectRatio) {
                    // Video is wider - fit to width
                    drawHeight = maxWidth / aspectRatio;
                    offsetY = (maxHeight - drawHeight) / 2;
                } else {
                    // Video is taller - fit to height
                    drawWidth = maxHeight * aspectRatio;
                    offsetX = (maxWidth - drawWidth) / 2;
                }
                
                // Draw video frame
                ctx.drawImage(video, offsetX, offsetY, drawWidth, drawHeight);
                
                // Draw detection canvas on top (with bounding boxes)
                if (detectionCanvas.width > 0 && detectionCanvas.height > 0) {
                    ctx.drawImage(detectionCanvas, offsetX, offsetY, drawWidth, drawHeight);
                }
                
                // Low quality to save storage space
                const thumbnail = compositeCanvas.toDataURL('image/jpeg', 0.35);
                
                // Create event object
                const event = {
                    frame_id: result.frame_id,
                    stream_id: result.stream_id || 'default',
                    timestamp: result.timestamp * 1000 || Date.now(),  // Convert to milliseconds
                    violence_score: result.violence_score || 0,
                    objects: result.objects || [],
                    thumbnail: thumbnail,
                    reviewed: false,
                    manual_verdict: null,
                    notes: ''
                };
                
                // Add to events list
                liveEvents.unshift(event);  // Add to beginning (newest first)
                
                // Limit to last 100 events (reduced from 500 to prevent storage overflow)
                if (liveEvents.length > 100) {
                    liveEvents = liveEvents.slice(0, 100);
                }
                
                // Save to storage with error handling
                saveLiveEventsToStorage();
                
                // Update live events tab if it's active
                const liveEventsTab = document.getElementById('live-events');
                if (liveEventsTab && liveEventsTab.classList.contains('active')) {
                    renderLiveEventsTable();
                }
                
                updateLiveStats();
                
                console.log('✅ Saved live event:', result.frame_id);
            } catch (error) {
                console.error('❌ Error saving live event:', error);
            }
        }
        
        function drawBoundingBoxes(objects) {
            const video = document.getElementById('livePreviewVideo');
            const canvas = document.getElementById('liveDetectionCanvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size to match video display size
            const rect = video.getBoundingClientRect();
            canvas.width = video.videoWidth || rect.width;
            canvas.height = video.videoHeight || rect.height;
            
            // Clear previous drawings
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Calculate scale factors (video actual size vs display size)
            const scaleX = canvas.width / (video.videoWidth || rect.width);
            const scaleY = canvas.height / (video.videoHeight || rect.height);
            
            // Draw each detection
            objects.forEach(obj => {
                const bbox = obj.bbox;
                const category = obj.category || 'other';
                const label = obj.label;
                const confidence = obj.confidence;
                
                // Color based on category
                let color;
                if (category === 'weapon') {
                    color = '#FF0000'; // Red
                } else if (category === 'substance') {
                    color = '#FFA500'; // Orange
                } else if (category === 'person') {
                    color = '#00FFFF'; // Cyan
                } else {
                    color = '#00FF00'; // Green
                }
                
                // Scale bbox coordinates
                const x1 = bbox.x1 * scaleX;
                const y1 = bbox.y1 * scaleY;
                const x2 = bbox.x2 * scaleX;
                const y2 = bbox.y2 * scaleY;
                const width = x2 - x1;
                const height = y2 - y1;
                
                // Draw rectangle
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.strokeRect(x1, y1, width, height);
                
                // Draw label background
                const labelText = `${label} ${(confidence * 100).toFixed(0)}%`;
                ctx.font = '14px Arial';
                const textMetrics = ctx.measureText(labelText);
                const textHeight = 20;
                
                ctx.fillStyle = color;
                ctx.fillRect(x1, y1 - textHeight, textMetrics.width + 10, textHeight);
                
                // Draw label text
                ctx.fillStyle = '#000000';
                ctx.fillText(labelText, x1 + 5, y1 - 5);
            });
        }
        
        async function startContinuousAnalysis() {
            // Analyze every frame (throttled to ~2 FPS to avoid overload)
            liveAnalysisInterval = setInterval(async () => {
                const frame = await captureFrame();
                if (frame) {
                    analyzeFrame(frame);
                }
            }, 500); // 2 FPS
        }
        
        async function startIntervalAnalysis(interval) {
            // Analyze at specified interval
            liveAnalysisInterval = setInterval(async () => {
                const frame = await captureFrame();
                if (frame) {
                    analyzeFrame(frame);
                }
            }, interval);
        }
        
        async function startMotionTriggeredAnalysis() {
            // Implement basic motion detection
            let previousFrame = null;
            
            liveAnalysisInterval = setInterval(async () => {
                const frame = await captureFrame();
                
                if (frame && previousFrame) {
                    // Simple motion detection: compare frames
                    const motionDetected = await detectMotion(previousFrame, frame);
                    
                    if (motionDetected) {
                        analyzeFrame(frame);
                    }
                }
                
                previousFrame = frame;
            }, 200); // Check for motion every 200ms
        }
        
        async function detectMotion(prevBlob, currBlob) {
            // Simple motion detection by comparing image data
            // In production, use more sophisticated algorithms
            return Math.random() > 0.7; // Placeholder: 30% chance of "motion"
        }
        
        // Video Preview Modal Functions
        async function openVideoPreview(videoId) {
            console.log('openVideoPreview called with videoId:', videoId);
            const video = videoQueue.find(v => v.id === videoId);
            if (!video) {
                console.warn('Video not found:', videoId);
                return;
            }
            
            console.log('Video found:', video.filename, 'Switching to original view');
            
            // Make sure the video is selected in the file tree
            selectFileTreeVideo(videoId);
            
            // Wait a moment for the pipeline view to render
            setTimeout(() => {
                // Switch to original video view
                switchVideoType('original');
            }, 100);
        }
        
        function switchVideoType(type) {
            const videoPlayer = document.getElementById('rightPaneVideoPlayer');
            const labeledBtn = document.getElementById('labeledVideoBtn');
            const originalBtn = document.getElementById('originalVideoBtn');
            
            if (!videoPlayer || !labeledBtn || !originalBtn) {
                console.warn('Video player or buttons not found');
                return;
            }
            
            const video = videoQueue.find(v => v.id === currentViewingVideo);
            if (!video) return;
            
            if (type === 'labeled') {
                // Show labeled video
                const labeledUrl = video.result && video.result.metadata && video.result.metadata.video_id ?
                    `${API_URL}/video/labeled/${video.result.metadata.video_id}` : '';
                
                if (labeledUrl) {
                    videoPlayer.src = labeledUrl;
                    labeledBtn.style.background = 'var(--primary)';
                    labeledBtn.style.color = 'var(--black)';
                    originalBtn.style.background = 'transparent';
                    originalBtn.style.color = 'var(--gray-light)';
                    console.log('Switched to labeled video');
                } else {
                    console.warn('Labeled video not available');
                }
            } else if (type === 'original') {
                // Show original video
                let originalUrl = null;
                
                if (video.file) {
                    // Use File object
                    originalUrl = URL.createObjectURL(video.file);
                    console.log('Loading original from File object');
                } else if (video.batchVideoId) {
                    // Try to fetch from backend
                    fetch(`${API_URL}/video/uploaded/${video.batchVideoId}`)
                        .then(response => {
                            if (response.ok) {
                                return response.blob();
                            } else {
                                throw new Error('Video not found');
                            }
                        })
                        .then(blob => {
                            const url = URL.createObjectURL(blob);
                            videoPlayer.src = url;
                            console.log('Loaded original from backend');
                        })
                        .catch(error => {
                            console.error('Failed to load original video:', error);
                            alert('Original video not available. It may have been cleaned up from the server.');
                            // Switch back to labeled
                            switchVideoType('labeled');
                        });
                    
                    // Set button styles immediately
                    originalBtn.style.background = 'var(--primary)';
                    originalBtn.style.color = 'var(--black)';
                    labeledBtn.style.background = 'transparent';
                    labeledBtn.style.color = 'var(--gray-light)';
                    return;
                } else {
                    console.warn('Original video not available');
                    alert('Original video not available. This happens after a page reload.');
                    return;
                }
                
                if (originalUrl) {
                    videoPlayer.src = originalUrl;
                    originalBtn.style.background = 'var(--primary)';
                    originalBtn.style.color = 'var(--black)';
                    labeledBtn.style.background = 'transparent';
                    labeledBtn.style.color = 'var(--gray-light)';
                    console.log('Switched to original video');
                }
            }
        }
        
        function closeVideoPreview() {
            const modal = document.getElementById('videoPreviewModal');
            const previewVideo = document.getElementById('previewVideo');
            
            previewVideo.pause();
            previewVideo.src = '';
            modal.style.display = 'none';
            document.body.style.overflow = ''; // Re-enable background scrolling
        }
        
        // Close modal on ESC key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeVideoPreview();
            }
        });
        
        function closePipelineView() {
            // Hide pipeline view, show batch panel
            document.getElementById('pipelineViewPanel').style.display = 'none';
            document.getElementById('batchPanel').style.display = 'block';
            
            // Reset stage output to default message
            const stageOutputContent = document.getElementById('stageOutputContent');
            if (stageOutputContent) {
                stageOutputContent.innerHTML = `
                    <div style="padding: 40px; text-align: center; color: var(--gray-light);">
                        <div style="font-size: 1.2em; margin-bottom: 10px;">Select a stage to view details</div>
                        <div style="font-size: 0.9em;">Click on any pipeline stage to see its output</div>
                    </div>
                `;
            }
            
            currentViewingVideo = null;
            
            // Reset analytics view to batch mode
            document.getElementById('analyticsResults').style.display = 'none';
            document.getElementById('batchAnalytics').style.display = 'block';
            
            // Switch back to pipeline tab (which shows the queue)
            document.querySelectorAll('.sidebar-link').forEach(l => l.classList.remove('active'));
            const pipelineTab = document.querySelector('.sidebar-link[data-tab="pipeline"]');
            if (pipelineTab) {
                pipelineTab.classList.add('active');
            }
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            const pipelineContent = document.getElementById('pipeline');
            if (pipelineContent) {
                pipelineContent.classList.add('active');
            }
            
            // Scroll to top
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // ===== UTILITY & DISPLAY FUNCTIONS =====
        
        function handleFileSelect_LEGACY(file) {
            if (!file.type.startsWith('video/')) {
                showError('Invalid file type. Please select a video file.');
                return;
            }

            if (file.size > 500 * 1024 * 1024) {
                showError('File too large. Maximum size is 500MB.');
                return;
            }

            selectedFile = file;
            fileName.textContent = file.name;
            fileSize.textContent = formatFileSize(file.size);
            fileInfo.classList.add('show');
            analyzeBtn.disabled = false;
            
            // Update step indicator
            const stepIndicator = document.getElementById('stepIndicator');
            stepIndicator.innerHTML = `
                <div class="step-number">STEP 2 OF 3</div>
                <div class="step-title">READY TO ANALYZE</div>
            `;
            
            // Smooth scroll to analyze button
            setTimeout(() => {
                analyzeBtn.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }, 100);
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }


        function resetPipelineUI() {
            // Reset stage start times
            stageStartTimes = {};
            
            // Reset all stages
            document.querySelectorAll('.pipeline-stage').forEach(stage => {
                stage.classList.remove('active', 'completed');
                const timeEl = stage.querySelector('.stage-time');
                if (timeEl) timeEl.textContent = '';
            });
            
            // Reset progress bar
            document.getElementById('progressFill').style.width = '0%';
            document.getElementById('stageDescription').textContent = 'Initializing analysis...';
        }

        function updatePipelineProgress(stage, message, progress) {
            // Track stage timing
            const now = Date.now();
            if (!stageStartTimes[stage]) {
                stageStartTimes[stage] = now;
            }
            
            // Update progress bar
            const progressFill = document.getElementById('progressFill');
            if (progressFill) {
                progressFill.style.width = progress + '%';
            }
            
            // Stage description element removed from UI
            
            // Update pipeline stages
            const stages = document.querySelectorAll('.pipeline-stage');
            stages.forEach(stageEl => {
                const stageName = stageEl.getAttribute('data-stage');
                const timeEl = stageEl.querySelector('.stage-time');
                
                if (stageName === stage) {
                    // Current stage - activate it
                    stageEl.classList.add('active');
                    stageEl.classList.remove('completed');
                    
                    // Show elapsed time for current stage
                    if (stageStartTimes[stage]) {
                        const elapsed = ((now - stageStartTimes[stage]) / 1000).toFixed(1);
                        if (timeEl) timeEl.textContent = `${elapsed}s`;
                    }
                } else {
                    // Check if completed (comes before current stage)
                    const currentIndex = Array.from(stages).findIndex(s => s.getAttribute('data-stage') === stage);
                    const thisIndex = Array.from(stages).indexOf(stageEl);
                    
                    if (thisIndex < currentIndex) {
                        stageEl.classList.add('completed');
                        stageEl.classList.remove('active');
                        
                        // Show final time for completed stage
                        if (stageStartTimes[stageName] && timeEl) {
                            const elapsed = ((now - stageStartTimes[stageName]) / 1000).toFixed(1);
                            timeEl.textContent = `${elapsed}s`;
                        }
                    } else {
                        stageEl.classList.remove('active', 'completed');
                        if (timeEl) timeEl.textContent = '';
                    }
                }
            });
            
            // If complete, mark all stages as completed
            if (stage === 'complete' || progress >= 100) {
                // Mark all stages as completed
                stages.forEach(stageEl => {
                    stageEl.classList.add('completed');
                    stageEl.classList.remove('active');
                });
                
                // DON'T hide loading state - keep pipeline visible!
                // The displayResults function will update the UI appropriately
            }
        }

        function displayResults(data) {
            // Store results for actions and stage details
            currentResults = data;
            currentAnalysisData = data; // Store for stage details modal
            
            // Update session stats
            sessionStats.videosAnalyzed++;
            sessionStats.violationsFound += data.violations.length;
            
            // Keep loading state visible (shows completed pipeline)
            // Update step indicator to show completion
            const stepIndicator = loadingState.querySelector('.step-indicator');
            if (stepIndicator) {
                stepIndicator.innerHTML = `
                    <div class="step-number">✓ COMPLETE</div>
                    <div class="step-title">PIPELINE FINISHED - CLICK ANY STAGE FOR DETAILS</div>
                `;
            }
            
            // Stage description element removed from UI
            
            // Set progress bar to 100%
            const progressFill = document.getElementById('progressFill');
            if (progressFill) {
                progressFill.style.width = '100%';
            }
            
            // Populate analytics tab with results
            document.getElementById('analyticsResults').style.display = 'block';
            document.getElementById('batchAnalytics').style.display = 'none';
            
            if (data.violations && data.violations.length > 0) {
                sessionStats.violationsFound += data.violations.length;
            }
            
            // Add to history
            analysisHistory.unshift({
                timestamp: new Date().toISOString(),
                fileName: selectedFile.name,
                verdict: data.verdict,
                violations: data.violations?.length || 0,
                duration: data.metadata?.duration,
                data: data
            });
            
            // Keep only last 20
            if (analysisHistory.length > 20) {
                analysisHistory.pop();
            }
            
            // Verdict
            const verdictBadge = document.getElementById('verdictBadge');
            verdictBadge.textContent = data.verdict;
            verdictBadge.className = `verdict-badge verdict-${data.verdict}`;

            // Verdict description
            const verdictDescriptions = {
                'SAFE': 'Content appears suitable for viewing based on safety criteria',
                'CAUTION': 'Content contains moderate indicators requiring supervision',
                'UNSAFE': 'Content contains significant violations and is not recommended',
                'NEEDS_REVIEW': 'Manual review recommended for final determination'
            };
            document.getElementById('verdictDescription').textContent = verdictDescriptions[data.verdict] || '';

            // Stats
            const statsGrid = document.getElementById('statsGrid');
            if (data.metadata) {
                statsGrid.innerHTML = `
                    <div class="stat-card">
                        <div class="stat-label">Duration</div>
                        <div class="stat-value">${data.metadata.duration?.toFixed(1)}s</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Violations</div>
                        <div class="stat-value">${data.violations?.length || 0}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Frames</div>
                        <div class="stat-value">${data.metadata.frames_analyzed}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Processing</div>
                        <div class="stat-value">${data.timings?.total_seconds?.toFixed(1) || '—'}s</div>
                    </div>
                `;
            }

            // Criteria - New Card Layout
            const criteriaGrid = document.getElementById('criteriaGrid');
            criteriaGrid.innerHTML = '';
            
            Object.entries(data.criteria).forEach(([name, info]) => {
                const score = info.score.toFixed(2);
                const percentage = Math.round(info.score * 100);
                const status = info.score < 0.3 ? 'safe' : info.score < 0.6 ? 'caution' : 'unsafe';
                const statusLabel = info.score < 0.3 ? 'LOW' : info.score < 0.6 ? 'MODERATE' : 'HIGH';
                
                const card = document.createElement('div');
                card.className = `criterion-analysis-card score-${status}`;
                card.innerHTML = `
                    <div class="criterion-analysis-name">${name.replace(/_/g, ' ')}</div>
                    <div class="criterion-analysis-score">${score}</div>
                    <div class="criterion-analysis-label">${statusLabel}</div>
                `;
                criteriaGrid.appendChild(card);
            });

            // Model Contributions
            populateModelContributions(data);

            // Violations - New Timeline Layout
            const violationsPanel = document.getElementById('violationsPanel');
            const violationsList = document.getElementById('violationsList');
            
            if (data.violations && data.violations.length > 0) {
                violationsPanel.style.display = 'block';
                violationsList.innerHTML = '';
                
                data.violations.forEach(violation => {
                    const item = document.createElement('div');
                    item.className = 'violation-item';
                    
                    const timeRanges = violation.timestamp_ranges.length > 0 
                        ? violation.timestamp_ranges.map(r => `${r[0].toFixed(1)}-${r[1].toFixed(1)}s`).join(', ')
                        : 'Throughout video';
                    
                    item.innerHTML = `
                        <div class="violation-time">${timeRanges}</div>
                        <div class="violation-details">
                            <div class="violation-criterion">${violation.criterion.replace(/_/g, ' ')}</div>
                            <div style="color: var(--gray-light); font-size: 0.9em;">
                                Confidence: ${(violation.score * 100).toFixed(0)}% • ${violation.evidence_refs.length} evidence point(s)
                            </div>
                            <div class="violation-severity ${violation.severity}">${violation.severity} severity</div>
                        </div>
                    `;
                    violationsList.appendChild(item);
                });
            } else {
                violationsPanel.style.display = 'none';
            }

            // Report (render markdown)
            const reportContent = document.getElementById('reportContent');
            reportContent.innerHTML = marked.parse(data.report);

            // Load video player
            const videoPlayer = document.getElementById('videoPlayer');
            const videoURL = URL.createObjectURL(selectedFile);
            videoPlayer.src = videoURL;
            
            // Render timeline markers
            renderTimelineMarkers(data.violations, data.metadata.duration);

            // Make completed pipeline stages clickable
            setTimeout(() => {
                makeStagesClickable();
            }, 500);
            
            // Scroll to top to show completed pipeline
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
        
        function renderTimelineMarkers(violations, duration) {
            const markersContainer = document.getElementById('timelineMarkers');
            markersContainer.innerHTML = '';
            
            if (!violations || violations.length === 0 || !duration) return;
            
            // Collect all timestamp ranges
            violations.forEach(violation => {
                if (violation.timestamp_ranges && violation.timestamp_ranges.length > 0) {
                    violation.timestamp_ranges.forEach(([start, end]) => {
                        const marker = document.createElement('div');
                        marker.className = 'timeline-marker';
                        
                        // Add tooltip
                        const tooltip = document.createElement('div');
                        tooltip.className = 'timeline-tooltip';
                        tooltip.textContent = `${violation.criterion}: ${start.toFixed(1)}s-${end.toFixed(1)}s (${(violation.score * 100).toFixed(0)}% confidence)`;
                        marker.appendChild(tooltip);
                        
                        // Calculate position and width as percentage
                        const leftPercent = (start / duration) * 100;
                        const widthPercent = ((end - start) / duration) * 100;
                        
                        marker.style.left = `${leftPercent}%`;
                        marker.style.width = `${Math.max(widthPercent, 0.5)}%`; // Minimum width for visibility
                        
                        // Click to seek video
                        marker.addEventListener('click', () => {
                            const videoPlayer = document.getElementById('videoPlayer');
                            videoPlayer.currentTime = start;
                            videoPlayer.play();
                        });
                        
                        markersContainer.appendChild(marker);
                    });
                }
            });
        }
        
        function populateModelContributions(data) {
            const container = document.getElementById('modelContributions');
            const evidence = data.evidence || {};
            
            const models = [
                {
                    name: 'YOLO26 Vision',
                    type: 'Object Detection',
                    detections: [
                        { label: 'Objects Detected', value: evidence.vision?.length || 0 },
                        { label: 'Weapons Found', value: evidence.vision?.filter(v => v.category === 'weapon').length || 0 },
                        { label: 'Violence Signals', value: evidence.vision?.filter(v => v.category === 'weapon' || v.label?.includes('blood')).length || 0 }
                    ]
                },
                {
                    name: 'X-CLIP Violence',
                    type: 'Action Recognition',
                    detections: [
                        { label: 'Segments Analyzed', value: evidence.violence_segments?.length || 0 },
                        { label: 'High Violence', value: evidence.violence_segments?.filter(s => s.violence_score > 0.5).length || 0 },
                        { label: 'Max Score', value: evidence.violence_segments ? Math.max(...evidence.violence_segments.map(s => s.violence_score), 0).toFixed(2) : '0.00' }
                    ]
                },
                {
                    name: 'Whisper ASR',
                    type: 'Audio Transcription',
                    detections: [
                        { label: 'Transcript Chunks', value: evidence.asr?.length || 0 },
                        { label: 'Words Transcribed', value: data.transcript?.text?.split(' ').length || 0 },
                        { label: 'Audio Duration', value: data.metadata?.duration ? data.metadata.duration.toFixed(1) + 's' : '—' }
                    ]
                },
                {
                    name: 'Text Moderation',
                    type: 'Content Classification',
                    detections: [
                        { label: 'Chunks Analyzed', value: evidence.transcript_moderation?.length || 0 },
                        { label: 'Flagged Content', value: evidence.transcript_moderation?.filter(m => m.profanity_score > 0.3 || m.sexual_score > 0.3 || m.hate_score > 0.3).length || 0 },
                        { label: 'Profanity Words', value: evidence.transcript_moderation?.reduce((sum, m) => sum + (m.profanity_words?.length || 0), 0) || 0 }
                    ]
                },
                {
                    name: 'EasyOCR',
                    type: 'Text Extraction',
                    detections: [
                        { label: 'Text Regions', value: evidence.ocr?.length || 0 },
                        { label: 'Frames Scanned', value: evidence.ocr?.filter((v, i, a) => a.findIndex(t => t.frame_index === v.frame_index) === i).length || 0 },
                        { label: 'Flagged Text', value: evidence.ocr_moderation?.filter(m => m.profanity_score > 0.3 || m.sexual_score > 0.3).length || 0 }
                    ]
                }
            ];

            container.innerHTML = `
                <div class="model-contribution-grid">
                    ${models.map(model => {
                        const totalDetections = model.detections.reduce((sum, d) => {
                            const val = typeof d.value === 'number' ? d.value : 0;
                            return sum + val;
                        }, 0);
                        
                        return `
                            <div class="model-card">
                                <div class="model-card-header">
                                    <div class="model-icon"></div>
                                    <div>
                                        <div class="model-name">${model.name}</div>
                                        <div class="model-type">${model.type}</div>
                                    </div>
                                </div>
                                <div class="model-detections">
                                    ${model.detections.map(det => {
                                        const value = det.value;
                                        const numValue = typeof value === 'number' ? value : 0;
                                        const level = numValue > 5 ? 'high' : numValue > 2 ? 'medium' : 'low';
                                        
                                        return `
                                            <div class="detection-row">
                                                <span class="detection-label">${det.label}</span>
                                                <span class="detection-value ${level}">${value}</span>
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }
        
        function approveVideo() {
            if (!currentResults) return;
            
            alert(`✓ Video "${selectedFile.name}" marked as APPROVED\n\nVerdict: ${currentResults.verdict}\nViolations: ${currentResults.violations?.length || 0}`);
            
            // In a real app, this would send to backend
            console.log('APPROVED:', currentResults);
        }
        
        function flagVideo() {
            if (!currentResults) return;
            
            const reason = prompt('Enter flag reason (optional):');
            alert(`⚠ Video "${selectedFile.name}" FLAGGED for review\n\nVerdict: ${currentResults.verdict}\nReason: ${reason || 'Manual review'}`);
            
            // In a real app, this would send to backend
            console.log('FLAGGED:', currentResults, 'Reason:', reason);
        }
        
        function exportResults() {
            if (!currentResults) return;
            
            const exportData = {
                filename: selectedFile.name,
                timestamp: new Date().toISOString(),
                ...currentResults
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `judex-analysis-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function updateAnalyticsTab() {
            // Show batch analytics, hide individual video analytics
            document.getElementById('batchAnalytics').style.display = 'block';
            document.getElementById('analyticsResults').style.display = 'none';
            
            // Update batch analytics
            const completedVideos = videoQueue.filter(v => v.status === 'completed');
            
            if (completedVideos.length === 0) {
                document.getElementById('batchAnalyticsEmpty').style.display = 'block';
                document.getElementById('batchAnalyticsContent').style.display = 'none';
                return;
            }
            
            document.getElementById('batchAnalyticsEmpty').style.display = 'none';
            document.getElementById('batchAnalyticsContent').style.display = 'block';
            
            // Update aggregate stats
            const total = videoQueue.length;
            const safe = videoQueue.filter(v => v.verdict === 'SAFE').length;
            const caution = videoQueue.filter(v => v.verdict === 'CAUTION').length;
            const unsafe = videoQueue.filter(v => v.verdict === 'UNSAFE').length;
            
            document.getElementById('analyticsTotal').textContent = total;
            document.getElementById('analyticsSafe').textContent = safe;
            document.getElementById('analyticsCaution').textContent = caution;
            document.getElementById('analyticsUnsafe').textContent = unsafe;
            
            // Aggregate violations by criteria
            const criteriaCount = {
                'violence': 0,
                'profanity': 0,
                'sexual': 0,
                'drugs': 0,
                'hate': 0
            };
            
            completedVideos.forEach(video => {
                if (video.result && video.result.violations) {
                    video.result.violations.forEach(violation => {
                        const criterion = violation.criterion.toLowerCase();
                        if (criteriaCount[criterion] !== undefined) {
                            criteriaCount[criterion]++;
                        }
                    });
                }
            });
            
            // Display criteria breakdown
            const criteriaBreakdown = document.getElementById('criteriaBreakdown');
            criteriaBreakdown.innerHTML = Object.entries(criteriaCount).map(([criterion, count]) => `
                <div style="background: var(--gray-dark); padding: 15px; border-left: 2px solid ${count > 0 ? '#ff0000' : 'var(--gray-medium)'};">
                    <div style="font-size: 0.75em; color: var(--gray-light); text-transform: uppercase; letter-spacing: 1px;">${criterion}</div>
                    <div style="font-size: 1.5em; font-weight: 500; color: ${count > 0 ? '#ff0000' : 'var(--white)'};">${count}</div>
                </div>
            `).join('');
        }
        
        function updateHistoryTab() {
            const completedVideos = videoQueue.filter(v => v.status === 'completed' || v.status === 'failed');
            const historyEmpty = document.getElementById('historyEmpty');
            const historyList = document.getElementById('historyList');
            const historyTableBody = document.getElementById('historyTableBody');
            const clearHistoryBtn = document.getElementById('clearHistoryBtn');
            
            if (completedVideos.length === 0) {
                historyEmpty.style.display = 'block';
                historyList.style.display = 'none';
                clearHistoryBtn.style.display = 'none';
                return;
            }
            
            historyEmpty.style.display = 'none';
            historyList.style.display = 'block';
            clearHistoryBtn.style.display = 'block';
            
            historyTableBody.innerHTML = completedVideos.map(video => {
                const timestamp = new Date().toLocaleTimeString();
                const violationsCount = video.result?.violations?.length || 0;
                const violationsText = violationsCount === 0 ? 'None' : 
                    video.result.violations.map(v => v.criterion).slice(0, 2).join(', ') + 
                    (violationsCount > 2 ? ` +${violationsCount - 2}` : '');
                
                return `
                    <tr>
                        <td style="font-weight: 500;">${video.filename}</td>
                        <td>
                            <span class="verdict-badge verdict-${(video.verdict || 'failed').toLowerCase()}" style="font-size: 0.7em; padding: 4px 8px;">
                                ${video.verdict || 'FAILED'}
                            </span>
                        </td>
                        <td style="color: var(--gray-light); font-size: 0.85em;">${timestamp}</td>
                        <td style="color: ${violationsCount > 0 ? '#ff0000' : 'var(--gray-light)'}; font-size: 0.85em;">
                            ${violationsText}
                        </td>
                        <td>
                            ${video.result ? `
                                <button class="icon-btn" onclick="viewVideoReport('${video.id}')" title="View Details">▶</button>
                            ` : '—'}
                        </td>
                    </tr>
                `;
            }).join('');
        }
        
        function clearHistory() {
            if (!confirm('Clear all completed videos from history?')) return;
            
            // Remove completed and failed videos
            videoQueue = videoQueue.filter(v => v.status !== 'completed' && v.status !== 'failed');
            
            // Update all displays
            renderVideoTable();
            updateHistoryTab();
            updateAnalyticsTab();
        }

        function showError(message) {
            const errorDisplay = document.getElementById('errorDisplay');
            const errorMessage = document.getElementById('errorMessage');
            
            if (errorMessage) {
                errorMessage.textContent = message;
            }
            
            if (errorDisplay) {
                errorDisplay.classList.add('show');
            }
            
            console.error('Error:', message);
        }

        function resetAnalysis() {
            // Clean up video player
            const videoPlayer = document.getElementById('videoPlayer');
            if (videoPlayer.src) {
                URL.revokeObjectURL(videoPlayer.src);
                videoPlayer.src = '';
            }
            
            // Close WebSocket if open
            if (websocket) {
                websocket.close();
                websocket = null;
            }

            selectedFile = null;
            currentAnalysisData = null;
            currentResults = null;
            fileInput.value = '';
            fileInfo.classList.remove('show');
            analyzeBtn.disabled = true;
            analyzeBtn.textContent = '▶ ANALYZE VIDEO';
            uploadPanel.style.display = 'block';
            uploadPanel.style.opacity = '1';
            uploadZone.classList.remove('uploading');
            errorDisplay.classList.remove('show');
            loadingState.classList.remove('show');
            
            // Reset analytics tab
            document.getElementById('analyticsResults').style.display = 'none';
            document.getElementById('systemAnalytics').style.display = 'block';
            document.getElementById('systemAnalyticsContent').style.display = 'block';
            
            // Switch back to pipeline tab
            document.querySelectorAll('.sidebar-link').forEach(l => l.classList.remove('active'));
            document.querySelector('[data-tab="pipeline"]').classList.add('active');
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.getElementById('pipeline').classList.add('active');
            
            // Reset step indicator
            const stepIndicator = document.getElementById('stepIndicator');
            if (stepIndicator) {
                stepIndicator.innerHTML = `
                    <div class="step-number">STEP 1 OF 3</div>
                    <div class="step-title">SELECT VIDEO FOR ANALYSIS</div>
                `;
            }
            
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // Check API status on load
        async function checkAPIStatus() {
            const statusEl = document.getElementById('apiHealthStatus');
            try {
                const response = await fetch(`${API_URL}/health`);
                if (response.ok) {
                    if (statusEl) statusEl.textContent = 'ONLINE';
                    if (statusEl) statusEl.style.color = 'var(--white)';
                } else {
                    if (statusEl) statusEl.textContent = 'ERROR';
                    if (statusEl) statusEl.style.color = '#ff0000';
                    console.warn('API health check failed');
                }
            } catch (error) {
                if (statusEl) statusEl.textContent = 'OFFLINE';
                if (statusEl) statusEl.style.color = '#ff0000';
                console.error('Cannot connect to API:', error);
            }
        }

        // Toggle video size
        function toggleVideoSize() {
            const videoContainer = document.getElementById('videoContainer');
            const expandBtn = document.getElementById('expandVideoBtn');
            
            if (videoContainer.classList.contains('compact')) {
                videoContainer.classList.remove('compact');
                videoContainer.classList.add('expanded');
                expandBtn.innerHTML = '⊟ COMPACT';
            } else {
                videoContainer.classList.add('compact');
                videoContainer.classList.remove('expanded');
                expandBtn.innerHTML = '⛶ EXPAND';
            }
        }

        // Switch to analytics tab
        function switchToAnalytics() {
            // Update active tab
            document.querySelectorAll('.sidebar-link').forEach(l => l.classList.remove('active'));
            document.querySelector('[data-tab="analytics"]').classList.add('active');
            
            // Show analytics tab content
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.getElementById('analytics').classList.add('active');
            
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // Close stage modal
        function closeStageModal() {
            const modal = document.getElementById('stageModal');
            modal.classList.remove('show');
            document.body.style.overflow = '';
        }
        
        // Close inline stage output

        // Show stage details inline (update content only, container always visible)
        function showStageDetails(stageName) {
            if (!currentAnalysisData) return;

            const title = document.getElementById('stageOutputTitle');
            const content = document.getElementById('stageOutputContent');

            const stageNames = {
                'ingest_video': '📥 VIDEO INGESTION',
                'segment_video': '✂️ VIDEO SEGMENTATION',
                'yolo26_vision': '👁️ YOLO26 VISION DETECTION',
                'yoloworld_vision': '🌍 YOLO-WORLD OPEN-VOCABULARY',  // NEW
                'violence_detection': '⚔️ VIOLENCE DETECTION',
                'audio_transcription': '🎤 AUDIO TRANSCRIPTION',
                'ocr_extraction': '📝 OCR TEXT EXTRACTION',
                'text_moderation': '🔒 TEXT MODERATION',
                'policy_fusion': '⚖️ POLICY FUSION & SCORING',
                'report_generation': '🤖 AI REPORT GENERATION',
                'finalize': '✅ FINALIZATION'
            };

            title.textContent = stageNames[stageName] || stageName.toUpperCase();
            content.innerHTML = generateStageContent(stageName, currentAnalysisData);
        }

        // Generate simplified stage content
        function generateStageContent(stageName, data) {
            const evidence = data.evidence || {};
            const metadata = data.metadata || {};
            
            // Debug logging for ingest stage
            if (stageName === 'ingest_video') {
                console.log('📊 Ingest Stage Data:', {
                    topLevel: { duration: data.duration, fps: data.fps, width: data.width, height: data.height, has_audio: data.has_audio },
                    metadata: metadata,
                    fullData: data
                });
            }

            let content = '<div style="line-height: 1.8;">';

            switch(stageName) {
                case 'ingest_video':
                    const duration = data.duration || metadata.duration;
                    const width = data.width || metadata.width;
                    const height = data.height || metadata.height;
                    const fps = data.fps || metadata.fps;
                    const hasAudio = data.has_audio !== undefined ? data.has_audio : (metadata.has_audio !== undefined ? metadata.has_audio : null);
                    const videoId = data.video_id || metadata.video_id;
                    const originalMeta = data.original_metadata || {};
                    
                    content += `
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px; margin-bottom: 20px;">
                            <div style="background: var(--black); padding: 15px; border: 1px solid var(--gray-medium);">
                                <div style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 5px;">DURATION</div>
                                <div style="font-size: 1.3em; color: var(--white); font-weight: 500;">${duration ? duration.toFixed(1) + 's' : 'N/A'}</div>
                            </div>
                            <div style="background: var(--black); padding: 15px; border: 1px solid var(--gray-medium);">
                                <div style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 5px;">RESOLUTION</div>
                                <div style="font-size: 1.3em; color: var(--white); font-weight: 500;">${width && height ? `${width}x${height}` : 'N/A'}</div>
                            </div>
                            <div style="background: var(--black); padding: 15px; border: 1px solid var(--gray-medium);">
                                <div style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 5px;">FPS</div>
                                <div style="font-size: 1.3em; color: var(--white); font-weight: 500;">${fps ? fps.toFixed(1) : 'N/A'}</div>
                            </div>
                            <div style="background: var(--black); padding: 15px; border: 1px solid var(--gray-medium);">
                                <div style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 5px;">AUDIO</div>
                                <div style="font-size: 1.3em; color: var(--white); font-weight: 500;">${hasAudio !== null ? (hasAudio ? '✓ Yes' : '✗ No') : 'N/A'}</div>
                            </div>
                        </div>
                        ${originalMeta.width || originalMeta.height || originalMeta.fps ? `
                            <div style="background: var(--gray-darker); padding: 12px; border-left: 3px solid var(--blue); margin-top: 10px;">
                                <div style="font-size: 0.9em; color: var(--gray-light); margin-bottom: 5px;">Original: ${originalMeta.width || 'N/A'}x${originalMeta.height || 'N/A'} @ ${originalMeta.fps ? originalMeta.fps.toFixed(1) : 'N/A'} fps</div>
                                <div style="font-size: 0.85em; color: var(--blue);">✓ Normalized to 720p @ 30fps for consistent processing</div>
                            </div>
                        ` : ''}
                        ${videoId ? `
                            <div style="background: var(--gray-darker); padding: 10px; margin-top: 10px; font-size: 0.85em; color: var(--gray-light);">
                                Video ID: <code style="color: var(--white); background: var(--black); padding: 2px 6px; border-radius: 2px;">${videoId}</code>
                            </div>
                        ` : ''}
                    `;
                    break;

                case 'segment_video':
                    const sampledFrames = data.sampled_frames || metadata.sampled_frames || (evidence.frames ? evidence.frames.length : null);
                    const segments = data.segments || metadata.segments || (evidence.violence_segments ? evidence.violence_segments.length : null);
                    const samplingFps = data.yolo_sampling_fps || metadata.sampling_fps || 1.0;
                    const videomaeConfig = data.videomae_config || {};
                    const segmentDuration = videomaeConfig.segment_duration || 2.0;
                    const stride = videomaeConfig.stride || 1.0;
                    const overlapPct = stride && segmentDuration ? ((segmentDuration - stride) / segmentDuration * 100).toFixed(0) : '50';
                    
                    content += `
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 12px; margin-bottom: 20px;">
                            <div style="background: var(--black); padding: 15px; border: 1px solid var(--gray-medium);">
                                <div style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 5px;">FRAMES EXTRACTED</div>
                                <div style="font-size: 1.3em; color: var(--white); font-weight: 500;">${Array.isArray(sampledFrames) ? sampledFrames.length : (sampledFrames || 'N/A')}</div>
                            </div>
                            <div style="background: var(--black); padding: 15px; border: 1px solid var(--gray-medium);">
                                <div style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 5px;">SAMPLING RATE</div>
                                <div style="font-size: 1.3em; color: var(--white); font-weight: 500;">${samplingFps} fps</div>
                            </div>
                            <div style="background: var(--black); padding: 15px; border: 1px solid var(--gray-medium);">
                                <div style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 5px;">VIDEOMAE SEGMENTS</div>
                                <div style="font-size: 1.3em; color: var(--white); font-weight: 500;">${Array.isArray(segments) ? segments.length : (segments || 'N/A')}</div>
                            </div>
                        </div>
                        ${videomaeConfig.segment_duration || videomaeConfig.stride ? `
                            <div style="background: var(--gray-darker); padding: 12px; border-left: 3px solid var(--blue); margin-bottom: 10px;">
                                <div style="font-size: 0.9em; color: var(--gray-light); margin-bottom: 5px;">
                                    <strong style="color: var(--white);">VideoMAE Configuration:</strong>
                                </div>
                                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; font-size: 0.85em; color: var(--gray-light);">
                                    <div>Window: <span style="color: var(--white)">${segmentDuration}s</span></div>
                                    <div>Stride: <span style="color: var(--white)">${stride}s</span></div>
                                    <div>Overlap: <span style="color: var(--blue)">${overlapPct}%</span></div>
                                </div>
                                <div style="margin-top: 8px; font-size: 0.85em; color: var(--blue);">
                                    ✓ 16 frames per segment @ 8fps (2-second context window)
                                </div>
                            </div>
                        ` : ''}
                        <div style="background: var(--gray-darker); padding: 10px; font-size: 0.85em; color: var(--gray-light);">
                            ℹ️ Tier 1 sparse scan: ${samplingFps} fps for YOLO, overlapping segments for VideoMAE
                        </div>
                    `;
                    break;

                case 'yolo26_vision':
                    const visionData = evidence.vision || [];
                    const objectCounts = {};
                    visionData.forEach(d => {
                        objectCounts[d.label] = (objectCounts[d.label] || 0) + 1;
                    });
                    const topObjects = Object.entries(objectCounts).sort((a, b) => b[1] - a[1]).slice(0, 10);
                    
                    content += `
                        <div style="margin-bottom: 20px; font-size: 1.1em;">
                            <strong>${visionData.length}</strong> objects detected across <strong>${Object.keys(objectCounts).length}</strong> categories
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px;">
                            ${topObjects.map(([label, count]) => `
                                <div style="display: flex; justify-content: space-between; padding: 12px; background: var(--black); border: 1px solid var(--gray-medium);">
                                    <span style="text-transform: capitalize;">${label}</span>
                                    <span style="color: var(--white); font-weight: 500;">${count}</span>
                                </div>
                            `).join('')}
                        </div>
                    `;
                    break;

                case 'yoloworld_vision':  // NEW
                    const yoloworldData = evidence.yoloworld || [];
                    const matchedPrompts = [...new Set(yoloworldData.map(d => d.prompt_match || d.label))];
                    const yoloworldCounts = {};
                    yoloworldData.forEach(d => {
                        const label = d.prompt_match || d.label;
                        yoloworldCounts[label] = (yoloworldCounts[label] || 0) + 1;
                    });
                    
                    content += `
                        <div style="margin-bottom: 20px; font-size: 1.1em;">
                            <strong>${yoloworldData.length}</strong> detections from <strong>${matchedPrompts.length}</strong> prompts
                        </div>
                        ${matchedPrompts.length > 0 ? `
                            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px;">
                                ${matchedPrompts.map(prompt => `
                                    <div style="background: var(--black); padding: 12px; border: 1px solid var(--gray-medium); border-radius: 4px;">
                                        <div style="font-weight: 500; color: var(--primary); margin-bottom: 4px;">${prompt}</div>
                                        <div style="font-size: 0.9em; color: var(--gray-light);">${yoloworldCounts[prompt]} detections</div>
                                    </div>
                                `).join('')}
                            </div>
                        ` : '<div style="color: var(--gray-light); padding: 20px; text-align: center;">No custom prompts matched</div>'}
                    `;
                    break;

                case 'violence_detection':
                    const violenceSegments = evidence.violence_segments || [];
                    const highViolence = violenceSegments.filter(s => s.violence_score > 0.5);
                    const maxScore = Math.max(...violenceSegments.map(s => s.violence_score || 0), 0);
                    
                    content += `
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-bottom: 20px;">
                            <div style="background: var(--black); padding: 15px; border: 1px solid var(--gray-medium);">
                                <div style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 5px;">SEGMENTS ANALYZED</div>
                                <div style="font-size: 1.3em; color: var(--white); font-weight: 500;">${violenceSegments.length}</div>
                            </div>
                            <div style="background: var(--black); padding: 15px; border: 1px solid var(--gray-medium);">
                                <div style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 5px;">HIGH VIOLENCE</div>
                                <div style="font-size: 1.3em; color: ${highViolence.length > 0 ? '#ff0000' : 'var(--white)'}; font-weight: 500;">${highViolence.length}</div>
                            </div>
                            <div style="background: var(--black); padding: 15px; border: 1px solid var(--gray-medium);">
                                <div style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 5px;">MAX SCORE</div>
                                <div style="font-size: 1.3em; color: ${maxScore > 0.5 ? '#ff0000' : 'var(--white)'}; font-weight: 500;">${maxScore.toFixed(2)}</div>
                            </div>
                        </div>
                        ${highViolence.length > 0 ? `
                            <div style="font-weight: 500; margin-bottom: 10px;">High Violence Segments:</div>
                            ${highViolence.slice(0, 3).map(seg => `
                                <div style="background: var(--black); padding: 12px; margin-bottom: 8px; border-left: 3px solid #ff0000;">
                                    <div style="display: flex; justify-content: space-between;">
                                        <span>${seg.start_time != null ? seg.start_time.toFixed(1) + 's' : 'N/A'} - ${seg.end_time != null ? seg.end_time.toFixed(1) + 's' : 'N/A'}</span>
                                        <span style="color: #ff0000; font-weight: 500;">Score: ${seg.violence_score != null ? seg.violence_score.toFixed(2) : 'N/A'}</span>
                                    </div>
                                </div>
                            `).join('')}
                        ` : '<div style="color: var(--gray-light);">No high violence detected</div>'}
                    `;
                    break;

                case 'audio_transcription':
                    // Try both result.transcript and evidence.asr
                    const transcript = data.transcript || evidence.transcript || {};
                    const chunks = transcript.chunks || evidence.asr || [];
                    const fullText = transcript.text || '';
                    
                    content += `
                        <div style="margin-bottom: 15px; font-size: 1.1em;">
                            <strong>${chunks.length}</strong> speech chunks transcribed ${transcript.language ? `(Language: ${transcript.language})` : ''}
                        </div>
                        ${fullText ? `
                            <div style="background: var(--gray-dark); padding: 15px; margin-bottom: 15px; border-left: 3px solid var(--white);">
                                <strong style="display: block; margin-bottom: 10px; color: var(--white);">Full Transcript:</strong>
                                <div style="line-height: 1.6; color: var(--gray-light);">${fullText}</div>
                            </div>
                        ` : ''}
                        ${chunks.length > 0 ? `
                            <strong style="display: block; margin-bottom: 10px; color: var(--white);">Timestamped Chunks:</strong>
                            ${chunks.slice(0, 8).map(chunk => `
                                <div style="background: var(--black); padding: 12px; margin-bottom: 8px; border-left: 2px solid var(--white);">
                                    <div style="color: var(--gray-light); font-size: 0.85em; margin-bottom: 5px;">
                                        ${chunk.start_time != null ? chunk.start_time.toFixed(1) + 's' : (chunk.timestamp && chunk.timestamp[0] != null ? chunk.timestamp[0].toFixed(1) + 's' : 'N/A')} - ${chunk.end_time != null ? chunk.end_time.toFixed(1) + 's' : (chunk.timestamp && chunk.timestamp[1] != null ? chunk.timestamp[1].toFixed(1) + 's' : 'N/A')}
                                    </div>
                                    <div>${chunk.text}</div>
                                </div>
                            `).join('')}
                            ${chunks.length > 8 ? `<div style="text-align: center; color: var(--gray-light); margin-top: 10px;">... and ${chunks.length - 8} more chunks</div>` : ''}
                        ` : '<div style="color: var(--gray-light);">No speech detected</div>'}
                    `;
                    break;

                case 'ocr_extraction':
                    const ocrHits = evidence.ocr || [];
                    
                    // Calculate statistics
                    const totalTexts = ocrHits.length;
                    const totalChars = ocrHits.reduce((sum, hit) => sum + (hit.text?.length || 0), 0);
                    const avgConfidence = ocrHits.length > 0 
                        ? ocrHits.reduce((sum, hit) => sum + (hit.detections?.[0]?.confidence || 0.5), 0) / ocrHits.length 
                        : 0;
                    
                    content += `
                        <div style="margin-bottom: 15px;">
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-bottom: 20px;">
                                <div style="background: var(--gray-dark); padding: 15px; border-left: 3px solid var(--white);">
                                    <div style="font-size: 0.85em; color: var(--gray-light); margin-bottom: 5px;">TEXT REGIONS</div>
                                    <div style="font-size: 1.8em; font-weight: 500;">${totalTexts}</div>
                                </div>
                                <div style="background: var(--gray-dark); padding: 15px; border-left: 3px solid var(--blue);">
                                    <div style="font-size: 0.85em; color: var(--gray-light); margin-bottom: 5px;">CHARACTERS</div>
                                    <div style="font-size: 1.8em; font-weight: 500;">${totalChars}</div>
                                </div>
                                <div style="background: var(--gray-dark); padding: 15px; border-left: 3px solid var(--green);">
                                    <div style="font-size: 0.85em; color: var(--gray-light); margin-bottom: 5px;">AVG CONFIDENCE</div>
                                    <div style="font-size: 1.8em; font-weight: 500;">${(avgConfidence * 100).toFixed(0)}%</div>
                                </div>
                            </div>
                        </div>
                        ${ocrHits.length > 0 ? `
                            <strong style="display: block; margin-bottom: 10px; color: var(--white);">Detected Text:</strong>
                            ${ocrHits.slice(0, 10).map((hit, idx) => {
                                const confidence = hit.detections?.[0]?.confidence || 0.5;
                                const confidenceColor = confidence > 0.8 ? 'var(--green)' : confidence > 0.5 ? 'var(--orange)' : 'var(--gray-light)';
                                return `
                                    <div style="background: var(--black); padding: 12px; margin-bottom: 8px; border-left: 2px solid ${confidenceColor};">
                                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                            <span style="color: var(--gray-light); font-size: 0.85em;">
                                                Frame ${hit.frame_index || idx} @ ${hit.timestamp?.toFixed(1) || 'N/A'}s
                                            </span>
                                            <span style="color: ${confidenceColor}; font-size: 0.85em; font-weight: 500;">
                                                ${(confidence * 100).toFixed(0)}% confidence
                                            </span>
                                        </div>
                                        <div style="color: var(--white); font-size: 1.05em;">"${hit.text}"</div>
                                    </div>
                                `;
                            }).join('')}
                            ${ocrHits.length > 10 ? `<div style="text-align: center; color: var(--gray-light); padding: 10px;">... and ${ocrHits.length - 10} more text detections</div>` : ''}
                        ` : '<div style="color: var(--gray-light); padding: 15px; background: var(--gray-darker);">No text detected in video frames</div>'}
                    `;
                    break;

                case 'text_moderation':
                    const transcriptMod = data.transcript_moderation || evidence.transcript_moderation || [];
                    const ocrMod = data.ocr_moderation || evidence.ocr_moderation || [];
                    const flaggedTranscript = transcriptMod.filter(m => m.profanity_score > 0.3 || m.sexual_score > 0.3 || m.hate_score > 0.3 || m.violence_score > 0.3 || m.drugs_score > 0.3);
                    const flaggedOcr = ocrMod.filter(m => m.profanity_score > 0.3 || m.sexual_score > 0.3 || m.hate_score > 0.3 || m.violence_score > 0.3 || m.drugs_score > 0.3);
                    
                    content += `
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-bottom: 20px;">
                            <div style="background: var(--black); padding: 15px; border: 1px solid var(--gray-medium);">
                                <div style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 5px;">TRANSCRIPT CHUNKS</div>
                                <div style="font-size: 1.3em; color: var(--white); font-weight: 500;">${transcriptMod.length}</div>
                                <div style="font-size: 0.8em; color: ${flaggedTranscript.length > 0 ? '#ff0000' : 'var(--green)'}; margin-top: 5px;">
                                    ${flaggedTranscript.length} flagged
                                </div>
                            </div>
                            <div style="background: var(--black); padding: 15px; border: 1px solid var(--gray-medium);">
                                <div style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 5px;">OCR TEXTS</div>
                                <div style="font-size: 1.3em; color: var(--white); font-weight: 500;">${ocrMod.length}</div>
                                <div style="font-size: 0.8em; color: ${flaggedOcr.length > 0 ? '#ff0000' : 'var(--green)'}; margin-top: 5px;">
                                    ${flaggedOcr.length} flagged
                                </div>
                            </div>
                        </div>
                        
                        ${flaggedTranscript.length > 0 ? `
                            <div style="margin-bottom: 20px;">
                                <div style="font-weight: 500; margin-bottom: 10px; color: var(--white);">⚠️ Flagged Transcript Content:</div>
                                ${flaggedTranscript.slice(0, 5).map(mod => {
                                    const displayText = mod.text || mod.original_text || 'N/A';
                                    return `
                                    <div style="background: var(--black); padding: 12px; margin-bottom: 8px; border-left: 3px solid #ff0000;">
                                        <div style="margin-bottom: 8px; color: var(--white);">"${displayText}"</div>
                                        <div style="display: flex; gap: 12px; flex-wrap: wrap; font-size: 0.85em;">
                                            ${mod.profanity_score > 0.3 ? `<span style="color: var(--gray-light);">Profanity: <strong style="color: #ff6b6b;">${(mod.profanity_score * 100).toFixed(0)}%</strong></span>` : ''}
                                            ${mod.sexual_score > 0.3 ? `<span style="color: var(--gray-light);">Sexual: <strong style="color: #ff6b6b;">${(mod.sexual_score * 100).toFixed(0)}%</strong></span>` : ''}
                                            ${mod.hate_score > 0.3 ? `<span style="color: var(--gray-light);">Hate: <strong style="color: #ff6b6b;">${(mod.hate_score * 100).toFixed(0)}%</strong></span>` : ''}
                                            ${mod.violence_score > 0.3 ? `<span style="color: var(--gray-light);">Violence: <strong style="color: #ff6b6b;">${(mod.violence_score * 100).toFixed(0)}%</strong></span>` : ''}
                                            ${mod.drugs_score > 0.3 ? `<span style="color: var(--gray-light);">Drugs: <strong style="color: #ff6b6b;">${(mod.drugs_score * 100).toFixed(0)}%</strong></span>` : ''}
                                            ${mod.profanity_words && mod.profanity_words.length > 0 ? `<span style="color: #ff6b6b;">Words: [${mod.profanity_words.join(', ')}]</span>` : ''}
                                        </div>
                                        <div style="font-size: 0.8em; color: var(--gray-light); margin-top: 6px;">
                                            @ ${mod.start_time ? mod.start_time.toFixed(1) + 's' : (mod.timestamp ? mod.timestamp.toFixed(1) + 's' : 'N/A')}${mod.end_time ? ' - ' + mod.end_time.toFixed(1) + 's' : ''}
                                        </div>
                                    </div>
                                `}).join('')}
                                ${flaggedTranscript.length > 5 ? `<div style="text-align: center; color: var(--gray-light); margin-top: 10px;">... and ${flaggedTranscript.length - 5} more flagged chunks</div>` : ''}
                            </div>
                        ` : ''}
                        
                        ${transcriptMod.length > 0 && flaggedTranscript.length === 0 ? `
                            <div style="margin-bottom: 20px;">
                                <div style="font-weight: 500; margin-bottom: 10px; color: var(--white);">📝 Sample Transcript Chunks (All Clean):</div>
                                ${transcriptMod.slice(0, 3).map(mod => {
                                    const displayText = mod.text || mod.original_text || 'N/A';
                                    return `
                                    <div style="background: var(--black); padding: 12px; margin-bottom: 8px; border-left: 3px solid var(--green);">
                                        <div style="margin-bottom: 8px; color: var(--white);">"${displayText}"</div>
                                        <div style="font-size: 0.8em; color: var(--gray-light);">
                                            @ ${mod.start_time ? mod.start_time.toFixed(1) + 's' : (mod.timestamp ? mod.timestamp.toFixed(1) + 's' : 'N/A')}${mod.end_time ? ' - ' + mod.end_time.toFixed(1) + 's' : ''}
                                        </div>
                                    </div>
                                `}).join('')}
                                ${transcriptMod.length > 3 ? `<div style="text-align: center; color: var(--gray-light); margin-top: 10px;">... and ${transcriptMod.length - 3} more clean chunks</div>` : ''}
                            </div>
                        ` : ''}
                        
                        ${flaggedOcr.length > 0 ? `
                            <div style="margin-bottom: 20px;">
                                <div style="font-weight: 500; margin-bottom: 10px; color: var(--white);">⚠️ Flagged OCR Content:</div>
                                ${flaggedOcr.slice(0, 3).map(mod => {
                                    const displayText = mod.text || 'N/A';
                                    return `
                                    <div style="background: var(--black); padding: 12px; margin-bottom: 8px; border-left: 3px solid #ff9500;">
                                        <div style="margin-bottom: 8px; color: var(--white);">"${displayText}"</div>
                                        <div style="display: flex; gap: 12px; flex-wrap: wrap; font-size: 0.85em;">
                                            ${mod.profanity_score > 0.3 ? `<span style="color: var(--gray-light);">Profanity: <strong style="color: #ff9500;">${(mod.profanity_score * 100).toFixed(0)}%</strong></span>` : ''}
                                            ${mod.sexual_score > 0.3 ? `<span style="color: var(--gray-light);">Sexual: <strong style="color: #ff9500;">${(mod.sexual_score * 100).toFixed(0)}%</strong></span>` : ''}
                                            ${mod.hate_score > 0.3 ? `<span style="color: var(--gray-light);">Hate: <strong style="color: #ff9500;">${(mod.hate_score * 100).toFixed(0)}%</strong></span>` : ''}
                                            ${mod.violence_score > 0.3 ? `<span style="color: var(--gray-light);">Violence: <strong style="color: #ff9500;">${(mod.violence_score * 100).toFixed(0)}%</strong></span>` : ''}
                                            ${mod.drugs_score > 0.3 ? `<span style="color: var(--gray-light);">Drugs: <strong style="color: #ff9500;">${(mod.drugs_score * 100).toFixed(0)}%</strong></span>` : ''}
                                            ${mod.profanity_words && mod.profanity_words.length > 0 ? `<span style="color: #ff9500;">Words: [${mod.profanity_words.join(', ')}]</span>` : ''}
                                        </div>
                                        <div style="font-size: 0.8em; color: var(--gray-light); margin-top: 6px;">
                                            @ ${mod.timestamp ? mod.timestamp.toFixed(1) + 's' : 'N/A'}
                                        </div>
                                    </div>
                                `}).join('')}
                                ${flaggedOcr.length > 3 ? `<div style="text-align: center; color: var(--gray-light); margin-top: 10px;">... and ${flaggedOcr.length - 3} more flagged OCR texts</div>` : ''}
                            </div>
                        ` : ''}
                        
                        ${flaggedTranscript.length === 0 && flaggedOcr.length === 0 && (transcriptMod.length > 0 || ocrMod.length > 0) ? `
                            <div style="background: var(--gray-darker); padding: 20px; text-align: center; border-left: 3px solid var(--green);">
                                <div style="color: var(--green); font-size: 1.2em; margin-bottom: 5px;">✓ Clean Content</div>
                                <div style="color: var(--gray-light); font-size: 0.9em;">No flagged content detected in ${transcriptMod.length + ocrMod.length} analyzed texts</div>
                            </div>
                        ` : ''}
                        
                        ${transcriptMod.length === 0 && ocrMod.length === 0 ? `
                            <div style="background: var(--gray-darker); padding: 20px; text-align: center; border-left: 3px solid var(--gray-medium);">
                                <div style="color: var(--gray-light); font-size: 1em;">No text content to moderate</div>
                            </div>
                        ` : ''}
                    `;
                    break;

                case 'policy_fusion':
                    // Handle both possible criteria formats:
                    // 1. data.criteria = { violence: 0.15, profanity: 0.08, ... }
                    // 2. data.criteria = { violence: { score: 0.15, ... }, ... }
                    const criteria = data.criteria || {};
                    
                    // Debug log
                    console.log('Policy Fusion - criteria data:', criteria);
                    
                    content += `
                        <div style="text-align: center; font-size: 2.5em; font-weight: 500; margin: 20px 0; color: var(--white);">
                            ${data.verdict || 'UNKNOWN'}
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 15px;">
                            ${Object.entries(criteria).length > 0 ? Object.entries(criteria).map(([criterion, details]) => {
                                // Handle both formats
                                let score = 0;
                                if (typeof details === 'number') {
                                    score = details;
                                } else if (typeof details === 'object' && details !== null) {
                                    score = details.score || details.value || 0;
                                } else {
                                    score = parseFloat(details) || 0;
                                }
                                
                                const percentage = Math.round(score * 100);
                                const color = percentage >= 60 ? '#ff0000' : percentage >= 30 ? '#ffaa00' : '#00aa00';
                                return `
                                    <div style="background: var(--black); padding: 15px; border: 1px solid var(--gray-medium); text-align: center; border-left: 3px solid ${color};">
                                        <div style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 8px; text-transform: uppercase;">${criterion.replace(/_/g, ' ')}</div>
                                        <div style="font-size: 1.5em; color: ${color}; font-weight: 600;">
                                            ${percentage}%
                                        </div>
                                    </div>
                                `;
                            }).join('') : '<div style="color: var(--gray-light); text-align: center; padding: 20px;">No criteria scores available</div>'}
                        </div>
                    `;
                    break;

                case 'report_generation':
                    content += `
                        <div style="background: var(--black); padding: 20px; border: 1px solid var(--gray-medium); line-height: 1.8;">
                            ${marked.parse(data.report || 'Report not available')}
                        </div>
                    `;
                    break;

                case 'finalize':
                    content += `
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
                            <div style="background: var(--black); padding: 15px; border: 1px solid var(--gray-medium);">
                                <div style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 5px;">VERDICT</div>
                                <div style="font-size: 1.3em; color: var(--white); font-weight: 500;">${data.verdict}</div>
                            </div>
                            <div style="background: var(--black); padding: 15px; border: 1px solid var(--gray-medium);">
                                <div style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 5px;">VIOLATIONS</div>
                                <div style="font-size: 1.3em; color: ${(data.violations || []).length > 0 ? '#ff0000' : 'var(--white)'}; font-weight: 500;">${(data.violations || []).length}</div>
                            </div>
                            <div style="background: var(--black); padding: 15px; border: 1px solid var(--gray-medium);">
                                <div style="font-size: 0.8em; color: var(--gray-light); margin-bottom: 5px;">DURATION</div>
                                <div style="font-size: 1.3em; color: var(--white); font-weight: 500;">${metadata.duration?.toFixed(1)}s</div>
                            </div>
                        </div>
                        <div style="margin-top: 20px; padding: 15px; background: var(--black); border: 1px solid var(--gray-medium);">
                            ✓ All pipeline stages completed successfully. Results packaged and ready for review.
                        </div>
                    `;
                    break;

                default:
                    content += '<div style="color: var(--gray-light);">Stage output details will be available after analysis completes.</div>';
            }

            content += '</div>';
            return content;
        }

        // Make stages clickable after analysis completes
        function makeStagesClickable() {
            document.querySelectorAll('.pipeline-stage').forEach(stage => {
                const stageName = stage.getAttribute('data-stage');
                if (stageName && stage.classList.contains('completed')) {
                    stage.classList.add('clickable');
                    stage.style.cursor = 'pointer';
                    stage.onclick = () => showStageDetails(stageName);
                }
            });
        }

        // Close modal when clicking outside
        document.addEventListener('click', (e) => {
            const modal = document.getElementById('stageModal');
            if (e.target === modal) {
                closeStageModal();
            }
        });
        
        // Initialize live events on page load
        loadLiveEvents();
        
        // Update live events tab when it becomes active
        const liveEventsLink = document.querySelector('.sidebar-link[data-tab="live-events"]');
        if (liveEventsLink) {
            liveEventsLink.addEventListener('click', () => {
                renderLiveEventsTable();
            });
        }

    </script>
    </div> <!-- end main-content -->
</body>
</html>
